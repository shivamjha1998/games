<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Ball Bounce</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  html, body { height: 100%; overflow: hidden; background: #0c0c1d; touch-action: manipulation; }
  body { display: flex; align-items: center; justify-content: center; }
  canvas { display: block; }
  .home-link { position: fixed; top: 12px; left: 12px; color: rgba(255,255,255,0.7); text-decoration: none; font-family: system-ui, sans-serif; font-size: 0.8rem; z-index: 10; backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px); background: rgba(0,0,0,0.25); padding: 6px 14px; border-radius: 20px; transition: background 0.2s, color 0.2s; }
  .home-link:hover { color: #fff; background: rgba(0,0,0,0.45); }
</style>
</head>
<body>
<a class="home-link" href="index.html">&#8592; Games</a>
<canvas id="c"></canvas>
<script>
(() => {
  /**
   * Ball Bounce — Vertical platformer bouncing game
   * Tilt left/right to land on platforms and bounce higher.
   *
   * Controls: Touch sides / Arrow Keys to move, P to pause, M to mute
   * Rendering: Canvas 2D, 400x700 internal resolution
   * State machine: title → playing → gameover
   */

  const W = 400, H = 700;
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  canvas.width = W * dpr; canvas.height = H * dpr;
  ctx.scale(dpr, dpr);

  function resize() {
    const a = W / H;
    let w = window.innerWidth, h = window.innerHeight;
    if (w / h > a) w = h * a; else h = w / a;
    canvas.style.width = w + 'px'; canvas.style.height = h + 'px';
  }
  window.addEventListener('resize', resize); resize();

  const GRAVITY = 900;
  const BOUNCE_VY = -550;
  const SPRING_VY = -800;
  const BALL_R = 12;
  const PLAT_H = 12;
  const MOVE_SPEED = 300;

  // === CONFIGURATION ===
  // Platform spawning
  const PLAT_SPACING_MIN = 50;
  const PLAT_SPACING_RANGE = 60;
  const PLAT_WIDTH_MIN = 55;
  const PLAT_WIDTH_RANGE = 30;
  const INITIAL_PLATFORM_COUNT = 25;
  const PLATFORM_SPAWN_BUFFER = 200;
  const PLATFORM_DESPAWN_BUFFER = 50;
  // Moving platform
  const MOVING_AMPLITUDE = 60;
  const MOVING_PERIOD = 800;
  // Camera
  const CAMERA_ANCHOR = 0.4;
  const CAMERA_LERP = 0.1;
  // Star field
  const STAR_COUNT = 80;
  const STAR_DEPTH = 3000;
  const STAR_PARALLAX = 0.3;
  // Ball visuals
  const BALL_GLOW_BLUR = 15;
  const BALL_STRETCH_FACTOR = 0.0004;
  const BALL_STRETCH_MAX = 0.25;
  const BALL_SQUISH_MAX = 0.2;
  // Trail
  const TRAIL_INTERVAL = 0.03;
  // Particles
  const PARTICLE_DECAY = 3;
  const PARTICLE_GRAVITY = 200;
  const BOUNCE_PARTICLE_COUNT = 10;
  const BREAK_PARTICLE_COUNT = 14;
  const GOLDEN_PARTICLE_SPEED_MIN = 80;
  const GOLDEN_PARTICLE_SPEED_RANGE = 150;
  // Floating text
  const FLOATING_TEXT_SPEED = -80;
  const FLOATING_TEXT_DECAY = 1.5;
  // Screen effects
  const SHAKE_DECAY = 0.85;
  const SHAKE_THRESHOLD = 0.1;
  const FLASH_DECAY_FACTOR = 0.9;
  const DEATH_SHAKE_MAG = 10;
  const SPRING_SHAKE_MAG = 4;
  // Milestones
  const MILESTONE_INTERVAL = 10;
  const MILESTONE_PARTICLE_COUNT = 20;
  const NEW_BEST_PARTICLE_COUNT = 35;
  // Background
  const BG_CLIMB_DIVISOR = 8000;
  // Height score divisor
  const HEIGHT_SCORE_DIVISOR = 10;
  // Transitions
  const TRANSITION_DURATION = 0.3;
  const SLOW_MOTION_FACTOR = 0.25;
  const SLOW_MOTION_DURATION = 0.5;
  const GAME_OVER_FADE_SPEED = 3;
  // Audio
  const AUDIO_FADEOUT = 0.001;

  let state, score, bestScore, ball, platforms, camY, highestY, particles;
  let inputDir, lastTime, stars;
  let paused = false;

  let shakeMag = 0;
  let flashColor = null;
  let flashAlpha = 0;
  let floatingTexts = [];
  let trailTimer = 0;

  let muted = localStorage.getItem('ballbounce_muted') === 'true';

  let lastMilestone = 0;
  let newBestTriggered = false;
  let prevBestScore = 0;

  // === SCREEN TRANSITION VARIABLES ===
  let transitionAlpha = 0;      // fade-in overlay alpha (1 = black, 0 = clear)
  let transitionTimer = 0;       // countdown timer for transitions
  let slowMotion = false;        // whether slow-mo death is active
  let slowMotionTimer = 0;       // time remaining in slow-mo
  let gameOverFade = 0;          // game-over overlay fade progress (0 to 1)
  let gameOverFading = false;    // whether game-over is fading in

  // === AUDIO ENGINE ===
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  let actx;

  function initAudio() {
    if (!actx) actx = new AudioCtx();
    if (actx.state === 'suspended') actx.resume();
  }

  function tone(freq, dur, type, vol) {
    if (!actx || muted) return;
    const o = actx.createOscillator();
    const g = actx.createGain();
    o.type = type || 'sine';
    o.frequency.setValueAtTime(freq, actx.currentTime);
    g.gain.setValueAtTime(vol || 0.3, actx.currentTime);
    g.gain.exponentialRampToValueAtTime(AUDIO_FADEOUT, actx.currentTime + dur);
    o.connect(g);
    g.connect(actx.destination);
    o.start();
    o.stop(actx.currentTime + dur);
  }

  function sweep(f1, f2, dur, type, vol) {
    if (!actx || muted) return;
    const o = actx.createOscillator();
    const g = actx.createGain();
    o.type = type || 'sine';
    o.frequency.setValueAtTime(f1, actx.currentTime);
    o.frequency.exponentialRampToValueAtTime(f2, actx.currentTime + dur);
    g.gain.setValueAtTime(vol || 0.3, actx.currentTime);
    g.gain.exponentialRampToValueAtTime(AUDIO_FADEOUT, actx.currentTime + dur);
    o.connect(g);
    g.connect(actx.destination);
    o.start();
    o.stop(actx.currentTime + dur);
  }

  function noise(dur, vol) {
    if (!actx || muted) return;
    const buf = actx.createBuffer(1, actx.sampleRate * dur | 0, actx.sampleRate);
    const d = buf.getChannelData(0);
    for (let i = 0; i < d.length; i++) d[i] = Math.random() * 2 - 1;
    const s = actx.createBufferSource();
    const g = actx.createGain();
    s.buffer = buf;
    g.gain.setValueAtTime(vol || 0.15, actx.currentTime);
    g.gain.exponentialRampToValueAtTime(AUDIO_FADEOUT, actx.currentTime + dur);
    s.connect(g);
    g.connect(actx.destination);
    s.start();
  }

  // === SOUND EFFECTS ===
  // Ball lands on a normal platform
  function sndBounce() { tone(350, 0.06, 'sine', 0.2); }
  // Ball hits a spring platform — high bounce
  function sndSpring() { sweep(300, 900, 0.15, 'sine', 0.3); }
  // Breakable platform crumbles
  function sndBreak() { noise(0.1, 0.2); tone(200, 0.08, 'square', 0.15); }
  // Ball fell off the bottom — death
  function sndGameOver() { sweep(400, 80, 0.5, 'sawtooth', 0.25); noise(0.3, 0.15); }
  // Score milestone reached
  function sndMilestone() { tone(523, 0.08, 'sine', 0.25); setTimeout(() => tone(659, 0.08, 'sine', 0.25), 80); setTimeout(() => tone(784, 0.12, 'sine', 0.25), 160); }
  // New personal best
  function sndNewBest() { tone(523, 0.1, 'sine', 0.3); setTimeout(() => tone(659, 0.1, 'sine', 0.3), 100); setTimeout(() => tone(784, 0.1, 'sine', 0.3), 200); setTimeout(() => tone(1047, 0.2, 'sine', 0.3), 300); }

  function triggerShake(magnitude) { shakeMag = magnitude; }
  function triggerFlash(color, alpha) { flashColor = color; flashAlpha = alpha || 0.4; }

  function addFloatingText(x, y, text, color, size) {
    floatingTexts.push({ x, y, text, color: color || '#fff', size: size || 20, life: 1, vy: FLOATING_TEXT_SPEED });
  }

  function addGoldenParticles(x, y, count) {
    for (let i = 0; i < count; i++) {
      const a = Math.random() * Math.PI * 2;
      const sp = GOLDEN_PARTICLE_SPEED_MIN + Math.random() * GOLDEN_PARTICLE_SPEED_RANGE;
      particles.push({ x, y, vx: Math.cos(a) * sp, vy: Math.sin(a) * sp, life: 1, color: Math.random() > 0.5 ? '#FDCB6E' : '#F9CA24', size: 2 + Math.random() * 4 });
    }
  }

  function genStars() {
    stars = [];
    for (let i = 0; i < STAR_COUNT; i++) {
      stars.push({ x: Math.random() * W, y: Math.random() * STAR_DEPTH, size: 0.5 + Math.random() * 1.5, alpha: 0.3 + Math.random() * 0.5 });
    }
  }

  function init() {
    state = 'title';
    score = 0;
    bestScore = parseInt(localStorage.getItem('ballbounce_best') || '0');
    prevBestScore = bestScore;
    particles = [];
    floatingTexts = [];
    lastTime = 0;
    inputDir = 0;
    camY = 0;
    highestY = H - 100;
    paused = false;
    shakeMag = 0;
    flashColor = null;
    flashAlpha = 0;
    lastMilestone = 0;
    newBestTriggered = false;
    trailTimer = 0;

    ball = { x: W / 2, y: H - 100, vx: 0, vy: 0 };
    platforms = [];

    platforms.push({ x: W / 2 - 40, y: H - 60, w: 80, type: 'normal' });

    let py = H - 60;
    for (let i = 0; i < INITIAL_PLATFORM_COUNT; i++) {
      py -= PLAT_SPACING_MIN + Math.random() * PLAT_SPACING_RANGE;
      const pw = PLAT_WIDTH_MIN + Math.random() * PLAT_WIDTH_RANGE;
      const px = Math.random() * (W - pw);
      const type = randPlatType();
      platforms.push({ x: px, y: py, w: pw, type, phase: Math.random() * Math.PI * 2, baseX: px });
    }

    genStars();
  }

  function randPlatType() {
    const r = Math.random();
    if (r < 0.55) return 'normal';
    if (r < 0.75) return 'moving';
    if (r < 0.90) return 'breakable';
    return 'spring';
  }

  const PLAT_COLORS = { normal: '#00B894', moving: '#0984E3', breakable: '#E17055', spring: '#FDCB6E' };

  function tap() {
    if (state === 'title') { initAudio(); state = 'playing'; ball.vy = BOUNCE_VY; transitionAlpha = 1; transitionTimer = TRANSITION_DURATION; return; }
    if (state === 'gameover') { init(); return; }
  }

  function addBounceParticles(x, y, color) {
    for (let i = 0; i < BOUNCE_PARTICLE_COUNT; i++) {
      const a = -Math.PI * Math.random();
      const sp = 50 + Math.random() * 120;
      particles.push({ x, y, vx: Math.cos(a) * sp, vy: Math.sin(a) * sp, life: 1, color, size: 2 + Math.random() * 3 });
    }
  }

  function addBreakParticles(px, py, pw) {
    for (let i = 0; i < BREAK_PARTICLE_COUNT; i++) {
      const x = px + Math.random() * pw;
      const a = -Math.PI * 0.2 - Math.random() * Math.PI * 0.6;
      const sp = 40 + Math.random() * 100;
      particles.push({ x, y: py, vx: Math.cos(a) * sp, vy: Math.sin(a) * sp - 30, life: 1, color: Math.random() > 0.5 ? '#E17055' : '#D63031', size: 2 + Math.random() * 4 });
    }
  }

  function update(dt) {
    // Handle slow-motion death
    if (slowMotion) {
      dt *= SLOW_MOTION_FACTOR;
      slowMotionTimer -= dt * (1 / SLOW_MOTION_FACTOR); // Use real time, not slowed time
      if (slowMotionTimer <= 0) {
        slowMotion = false;
        state = 'gameover';
        gameOverFade = 0;
        gameOverFading = true;
      }
    }

    // Handle fade-in transition
    if (transitionTimer > 0) {
      transitionTimer -= dt;
      transitionAlpha = Math.max(0, transitionTimer / TRANSITION_DURATION);
    }

    // Handle game-over fade
    if (gameOverFading) {
      gameOverFade = Math.min(1, gameOverFade + dt * GAME_OVER_FADE_SPEED);
      if (gameOverFade >= 1) gameOverFading = false;
    }

    if (state !== 'playing') return;
    if (paused) return;

    ball.vx = inputDir * MOVE_SPEED;
    ball.x += ball.vx * dt;
    ball.vy += GRAVITY * dt;
    ball.y += ball.vy * dt;

    if (ball.x - BALL_R < 0) { ball.x = BALL_R; ball.vx *= -1; }
    if (ball.x + BALL_R > W) { ball.x = W - BALL_R; ball.vx *= -1; }

    trailTimer += dt;
    if (trailTimer > TRAIL_INTERVAL) {
      trailTimer = 0;
      particles.push({ x: ball.x + (Math.random() - 0.5) * 6, y: ball.y + BALL_R * 0.5, vx: (Math.random() - 0.5) * 15, vy: 10 + Math.random() * 20, life: 0.5, color: Math.random() > 0.5 ? '#FD79A8' : '#FF9FF3', size: 1.5 + Math.random() * 2 });
    }

    if (ball.vy > 0) {
      for (let i = platforms.length - 1; i >= 0; i--) {
        const p = platforms[i];
        if (ball.x + BALL_R > p.x && ball.x - BALL_R < p.x + p.w && ball.y + BALL_R >= p.y && ball.y + BALL_R - ball.vy * dt <= p.y + PLAT_H) {
          if (p.type === 'breakable') {
            sndBreak();
            addBreakParticles(p.x, p.y, p.w);
            addFloatingText(p.x + p.w / 2, p.y, '+1', '#E17055', 18);
            platforms.splice(i, 1);
            score++;
            continue;
          }
          const bounceV = p.type === 'spring' ? SPRING_VY : BOUNCE_VY;
          if (p.type === 'spring') {
            sndSpring();
            triggerShake(SPRING_SHAKE_MAG);
            addFloatingText(ball.x, p.y - 20, 'SPRING!', '#FDCB6E', 24);
          } else {
            sndBounce();
            addFloatingText(ball.x, p.y - 15, '+1', '#aaffaa', 16);
          }
          score++;
          ball.vy = bounceV;
          ball.y = p.y - BALL_R;
          addBounceParticles(ball.x, p.y, PLAT_COLORS[p.type]);
        }
      }
    }

    platforms.forEach(p => {
      if (p.type === 'moving') {
        p.x = p.baseX + Math.sin(Date.now() / MOVING_PERIOD + p.phase) * MOVING_AMPLITUDE;
      }
    });

    if (ball.y < camY + H * CAMERA_ANCHOR) {
      camY += (ball.y - camY - H * CAMERA_ANCHOR) * CAMERA_LERP;
    }

    if (ball.y < highestY) {
      highestY = ball.y;
    }

    const currentMilestone = Math.floor(score / MILESTONE_INTERVAL) * MILESTONE_INTERVAL;
    if (currentMilestone > lastMilestone && currentMilestone > 0) {
      lastMilestone = currentMilestone;
      sndMilestone();
      triggerFlash('#FDCB6E', 0.25);
      addFloatingText(W / 2, camY + H * 0.35, currentMilestone + '!', '#FDCB6E', 36);
      addGoldenParticles(W / 2, camY + H * CAMERA_ANCHOR, MILESTONE_PARTICLE_COUNT);
    }

    if (score > prevBestScore && prevBestScore > 0 && !newBestTriggered) {
      newBestTriggered = true;
      sndNewBest();
      triggerFlash('#FDCB6E', 0.35);
      addFloatingText(W / 2, camY + H * 0.3, 'NEW BEST!', '#F9CA24', 40);
      addGoldenParticles(W / 2, camY + H * 0.35, NEW_BEST_PARTICLE_COUNT);
    }

    const topEdge = camY - 100;
    const topPlat = platforms.reduce((min, p) => Math.min(min, p.y), Infinity);
    while (topPlat > topEdge - PLATFORM_SPAWN_BUFFER) {
      const py = topPlat - PLAT_SPACING_MIN - Math.random() * PLAT_SPACING_RANGE;
      const pw = PLAT_WIDTH_MIN + Math.random() * PLAT_WIDTH_RANGE;
      const px = Math.random() * (W - pw);
      platforms.push({ x: px, y: py, w: pw, type: randPlatType(), phase: Math.random() * Math.PI * 2, baseX: px });
      break;
    }

    if (platforms.length > 0) {
      const highest = platforms.reduce((min, p) => Math.min(min, p.y), Infinity);
      while (highest > camY - PLATFORM_SPAWN_BUFFER) {
        const py = highest - PLAT_SPACING_MIN - Math.random() * PLAT_SPACING_RANGE;
        const pw = PLAT_WIDTH_MIN + Math.random() * PLAT_WIDTH_RANGE;
        const px = Math.random() * (W - pw);
        platforms.push({ x: px, y: py, w: pw, type: randPlatType(), phase: Math.random() * Math.PI * 2, baseX: px });
        break;
      }
    }

    for (let i = platforms.length - 1; i >= 0; i--) {
      if (platforms[i].y > camY + H + PLATFORM_DESPAWN_BUFFER) platforms.splice(i, 1);
    }

    if (ball.y > camY + H + BALL_R && !slowMotion) {
      sndGameOver();
      triggerShake(DEATH_SHAKE_MAG);
      triggerFlash('#ff0000', 0.35);
      die();
    }

    if (shakeMag > SHAKE_THRESHOLD) { shakeMag *= SHAKE_DECAY; } else { shakeMag = 0; }
    if (flashAlpha > 0.005) { flashAlpha *= FLASH_DECAY_FACTOR; } else { flashAlpha = 0; flashColor = null; }

    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      p.x += p.vx * dt; p.y += p.vy * dt;
      p.vy += PARTICLE_GRAVITY * dt;
      p.life -= dt * PARTICLE_DECAY;
      if (p.life <= 0) particles.splice(i, 1);
    }

    for (let i = floatingTexts.length - 1; i >= 0; i--) {
      const ft = floatingTexts[i];
      ft.y += ft.vy * dt;
      ft.life -= dt * FLOATING_TEXT_DECAY;
      if (ft.life <= 0) floatingTexts.splice(i, 1);
    }
  }

  function die() {
    if (slowMotion) return; // Prevent multiple death triggers
    slowMotion = true;
    slowMotionTimer = SLOW_MOTION_DURATION;
    bestScore = Math.max(score, bestScore);
    localStorage.setItem('ballbounce_best', bestScore);
  }

  function render() {
    ctx.save();

    if (shakeMag > SHAKE_THRESHOLD) {
      const sx = (Math.random() - 0.5) * shakeMag * 2;
      const sy = (Math.random() - 0.5) * shakeMag * 2;
      ctx.translate(sx, sy);
    }

    const climb = Math.min(1, Math.max(0, -camY / BG_CLIMB_DIVISOR));
    const grad = ctx.createLinearGradient(0, 0, 0, H);
    const r1 = Math.round(12 + climb * 20);
    const g1 = Math.round(12 + climb * 5);
    const b1 = Math.round(29 + climb * 50);
    const r2 = Math.round(26 + climb * 60);
    const g2 = Math.round(26 + climb * 15);
    const b2 = Math.round(62 + climb * 80);
    const r3 = Math.round(15 + climb * 40);
    const g3 = Math.round(10 + climb * 8);
    const b3 = Math.round(40 + climb * 60);
    grad.addColorStop(0, 'rgb(' + r1 + ',' + g1 + ',' + b1 + ')');
    grad.addColorStop(0.5, 'rgb(' + r3 + ',' + g3 + ',' + b3 + ')');
    grad.addColorStop(1, 'rgb(' + r2 + ',' + g2 + ',' + b2 + ')');
    ctx.fillStyle = grad;
    ctx.fillRect(-10, -10, W + 20, H + 20);

    stars.forEach(s => {
      const sy = ((s.y - camY * STAR_PARALLAX) % STAR_DEPTH + STAR_DEPTH) % STAR_DEPTH - 1000;
      if (sy < -10 || sy > H + 10) return;
      ctx.globalAlpha = s.alpha * (0.7 + 0.3 * Math.sin(Date.now() / 1000 + s.x));
      ctx.fillStyle = '#fff';
      ctx.beginPath(); ctx.arc(s.x, sy, s.size, 0, Math.PI * 2); ctx.fill();
    });
    ctx.globalAlpha = 1;

    platforms.forEach(p => {
      const sy = p.y - camY;
      if (sy < -20 || sy > H + 20) return;

      ctx.fillStyle = PLAT_COLORS[p.type];
      ctx.shadowColor = PLAT_COLORS[p.type];
      ctx.shadowBlur = 6;
      roundRect(p.x, sy, p.w, PLAT_H, 6);
      ctx.shadowBlur = 0;

      if (p.type === 'moving') {
        ctx.strokeStyle = 'rgba(255,255,255,0.5)';
        ctx.lineWidth = 2;
        const cx = p.x + p.w / 2;
        const dir = Math.cos(Date.now() / MOVING_PERIOD + p.phase);
        // Left chevron
        ctx.beginPath();
        ctx.moveTo(cx - 10 + (dir < 0 ? -2 : 0), sy + PLAT_H / 2 - 4);
        ctx.lineTo(cx - 14 + (dir < 0 ? -2 : 0), sy + PLAT_H / 2);
        ctx.lineTo(cx - 10 + (dir < 0 ? -2 : 0), sy + PLAT_H / 2 + 4);
        ctx.stroke();
        // Right chevron
        ctx.beginPath();
        ctx.moveTo(cx + 10 + (dir > 0 ? 2 : 0), sy + PLAT_H / 2 - 4);
        ctx.lineTo(cx + 14 + (dir > 0 ? 2 : 0), sy + PLAT_H / 2);
        ctx.lineTo(cx + 10 + (dir > 0 ? 2 : 0), sy + PLAT_H / 2 + 4);
        ctx.stroke();
      }

      if (p.type === 'breakable') {
        ctx.strokeStyle = 'rgba(0,0,0,0.4)';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(p.x + p.w * 0.25, sy + 1);
        ctx.lineTo(p.x + p.w * 0.35, sy + PLAT_H * 0.5);
        ctx.lineTo(p.x + p.w * 0.28, sy + PLAT_H - 1);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(p.x + p.w * 0.55, sy + 1);
        ctx.lineTo(p.x + p.w * 0.65, sy + PLAT_H * 0.45);
        ctx.lineTo(p.x + p.w * 0.58, sy + PLAT_H - 1);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(p.x + p.w * 0.75, sy + 2);
        ctx.lineTo(p.x + p.w * 0.8, sy + PLAT_H - 2);
        ctx.stroke();
      }

      if (p.type === 'spring') {
        ctx.strokeStyle = '#E67E22';
        ctx.lineWidth = 2.5;
        ctx.lineCap = 'round';
        const cx = p.x + p.w / 2;
        const coilW = 10;
        const coilH = 14;
        const segments = 5;
        ctx.beginPath();
        ctx.moveTo(cx - coilW, sy);
        for (let s = 0; s < segments; s++) {
          const t = s / segments;
          const nextT = (s + 1) / segments;
          const midT = (t + nextT) / 2;
          const xDir = s % 2 === 0 ? 1 : -1;
          ctx.quadraticCurveTo(cx + coilW * xDir, sy - coilH * midT, cx - coilW * xDir, sy - coilH * nextT);
        }
        ctx.stroke();
        ctx.lineCap = 'butt';
      }
    });

    particles.forEach(p => {
      ctx.globalAlpha = Math.max(0, p.life);
      ctx.fillStyle = p.color;
      ctx.beginPath(); ctx.arc(p.x, p.y - camY, p.size, 0, Math.PI * 2); ctx.fill();
    });
    ctx.globalAlpha = 1;

    const stretch = 1 + Math.max(-BALL_SQUISH_MAX, Math.min(BALL_STRETCH_MAX, ball.vy * BALL_STRETCH_FACTOR));
    const squash = 1 / stretch;
    const bsy = ball.y - camY;

    ctx.save();
    ctx.translate(ball.x, bsy);
    ctx.scale(squash, stretch);

    ctx.shadowColor = '#FD79A8';
    ctx.shadowBlur = BALL_GLOW_BLUR;

    const bGrad = ctx.createRadialGradient(-3, -3, 2, 0, 0, BALL_R);
    bGrad.addColorStop(0, '#FF9FF3');
    bGrad.addColorStop(1, '#FD79A8');
    ctx.fillStyle = bGrad;
    ctx.beginPath(); ctx.arc(0, 0, BALL_R, 0, Math.PI * 2); ctx.fill();
    ctx.shadowBlur = 0;

    ctx.fillStyle = 'rgba(255,255,255,0.35)';
    ctx.beginPath(); ctx.arc(-3, -4, 5, 0, Math.PI * 2); ctx.fill();

    ctx.restore();

    floatingTexts.forEach(ft => {
      const fty = ft.y - camY;
      ctx.globalAlpha = Math.max(0, ft.life);
      ctx.fillStyle = ft.color;
      ctx.font = 'bold ' + ft.size + 'px "Avenir Next", "Segoe UI", system-ui, sans-serif';
      ctx.textAlign = 'center';
      ctx.shadowColor = ft.color;
      ctx.shadowBlur = 8;
      ctx.fillText(ft.text, ft.x, fty);
      ctx.shadowBlur = 0;
    });
    ctx.globalAlpha = 1;

    ctx.fillStyle = '#fff';
    ctx.font = 'bold 32px "Avenir Next", "Segoe UI", system-ui, sans-serif';
    ctx.textAlign = 'center';
    ctx.shadowColor = '#FD79A8';
    ctx.shadowBlur = 12;
    ctx.fillText(score, W / 2, 40);
    ctx.shadowColor = 'rgba(253,121,168,0.5)';
    ctx.shadowBlur = 25;
    ctx.fillText(score, W / 2, 40);
    ctx.shadowBlur = 0;

    if (flashColor && flashAlpha > 0.005) {
      ctx.globalAlpha = flashAlpha;
      ctx.fillStyle = flashColor;
      ctx.fillRect(-10, -10, W + 20, H + 20);
      ctx.globalAlpha = 1;
    }

    // Fade-in transition overlay
    if (transitionAlpha > 0) {
      ctx.fillStyle = 'rgba(0,0,0,' + transitionAlpha + ')';
      ctx.fillRect(-10, -10, W + 20, H + 20);
    }

    renderMuteIcon();

    ctx.restore();
  }

  // Mute button constants
  const MUTE_CX = W - 28, MUTE_CY = 28, MUTE_R = 20;
  let muteHovered = false;

  function renderMuteIcon() {
    ctx.save();
    ctx.beginPath();
    ctx.arc(MUTE_CX, MUTE_CY, MUTE_R, 0, Math.PI * 2);
    ctx.fillStyle = muteHovered ? 'rgba(0,0,0,0.45)' : 'rgba(0,0,0,0.3)';
    ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.fillRect(MUTE_CX - 12, MUTE_CY - 4, 6, 8);
    ctx.beginPath();
    ctx.moveTo(MUTE_CX - 6, MUTE_CY - 4);
    ctx.lineTo(MUTE_CX, MUTE_CY - 9);
    ctx.lineTo(MUTE_CX, MUTE_CY + 9);
    ctx.lineTo(MUTE_CX - 6, MUTE_CY + 4);
    ctx.closePath();
    ctx.fill();
    if (muted) {
      ctx.strokeStyle = '#ff6b6b'; ctx.lineWidth = 2.5; ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(MUTE_CX + 3, MUTE_CY - 5); ctx.lineTo(MUTE_CX + 11, MUTE_CY + 5);
      ctx.moveTo(MUTE_CX + 11, MUTE_CY - 5); ctx.lineTo(MUTE_CX + 3, MUTE_CY + 5);
      ctx.stroke();
    } else {
      ctx.strokeStyle = 'rgba(255,255,255,0.85)'; ctx.lineWidth = 1.8; ctx.lineCap = 'round';
      ctx.beginPath(); ctx.arc(MUTE_CX + 2, MUTE_CY, 5, -Math.PI * 0.35, Math.PI * 0.35); ctx.stroke();
      ctx.beginPath(); ctx.arc(MUTE_CX + 2, MUTE_CY, 10, -Math.PI * 0.35, Math.PI * 0.35); ctx.stroke();
    }
    if (muteHovered) {
      const label = muted ? 'Unmute (M)' : 'Mute (M)';
      ctx.font = '12px "Avenir Next", "Segoe UI", system-ui, sans-serif';
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      const tw = ctx.measureText(label).width + 14;
      const ty = MUTE_CY + MUTE_R + 14;
      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      ctx.beginPath(); ctx.roundRect(MUTE_CX - tw / 2, ty - 11, tw, 22, 6); ctx.fill();
      ctx.fillStyle = '#fff'; ctx.fillText(label, MUTE_CX, ty);
    }
    ctx.restore();
  }

  function renderPauseOverlay() {
    ctx.fillStyle = 'rgba(0,0,0,0.55)';
    ctx.fillRect(0, 0, W, H);

    ctx.fillStyle = '#fff';
    ctx.font = 'bold 44px "Avenir Next", "Segoe UI", system-ui, sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('PAUSED', W / 2, H * 0.38);

    const alpha = 0.5 + 0.5 * Math.sin(Date.now() / 500);
    ctx.globalAlpha = alpha;
    ctx.font = '22px "Avenir Next", "Segoe UI", system-ui, sans-serif';
    ctx.fillText('Press P to Resume', W / 2, H * 0.48);
    ctx.globalAlpha = 1;

    ctx.font = '16px "Avenir Next", "Segoe UI", system-ui, sans-serif';
    ctx.fillStyle = 'rgba(255,255,255,0.5)';
    ctx.fillText('M - Toggle Sound', W / 2, H * 0.55);
  }

  function renderTitle() {
    render();
    ctx.fillStyle = 'rgba(0,0,0,0.45)';
    ctx.fillRect(0, 0, W, H);

    ctx.fillStyle = '#FD79A8';
    ctx.font = 'bold 44px "Avenir Next", "Segoe UI", system-ui, sans-serif';
    ctx.textAlign = 'center';
    ctx.shadowColor = '#FD79A8';
    ctx.shadowBlur = 20;
    ctx.fillText('BALL', W / 2, H * 0.28);
    ctx.fillText('BOUNCE', W / 2, H * 0.36);
    ctx.shadowBlur = 0;

    ctx.fillStyle = '#fff';
    const alpha = 0.5 + 0.5 * Math.sin(Date.now() / 500);
    ctx.globalAlpha = alpha;
    ctx.font = '22px "Avenir Next", "Segoe UI", system-ui, sans-serif';
    ctx.fillText('Tap to Play', W / 2, H * 0.50);
    ctx.globalAlpha = 0.6;
    ctx.font = '16px "Avenir Next", "Segoe UI", system-ui, sans-serif';
    ctx.fillText('Tilt left/right to land on platforms!', W / 2, H * 0.545);
    ctx.globalAlpha = 1;

    ctx.font = '14px "Avenir Next", "Segoe UI", system-ui, sans-serif';
    ctx.fillStyle = 'rgba(255,255,255,0.5)';
    ctx.fillText('Touch sides or Arrow Keys to move', W / 2, H * 0.59);
    ctx.fillText('P = Pause   M = Mute', W / 2, H * 0.63);

    if (bestScore > 0) {
      ctx.fillStyle = '#FDCB6E';
      ctx.font = '18px "Avenir Next", "Segoe UI", system-ui, sans-serif';
      ctx.fillText('Best: ' + bestScore, W / 2, H * 0.70);
    }
  }

  function renderGameOver() {
    render();
    ctx.fillStyle = 'rgba(0,0,0,' + (0.65 * gameOverFade) + ')';
    ctx.fillRect(0, 0, W, H);

    ctx.globalAlpha = gameOverFade;

    ctx.fillStyle = '#fff';
    ctx.font = 'bold 44px "Avenir Next", "Segoe UI", system-ui, sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Game Over', W / 2, H * 0.28);
    ctx.font = 'bold 64px "Avenir Next", "Segoe UI", system-ui, sans-serif';
    ctx.fillText(score, W / 2, H * 0.42);
    ctx.font = '20px "Avenir Next", "Segoe UI", system-ui, sans-serif';
    ctx.fillStyle = '#FDCB6E';
    ctx.fillText('Best: ' + bestScore, W / 2, H * 0.50);

    ctx.fillStyle = 'rgba(255,255,255,0.55)';
    ctx.font = '16px "Avenir Next", "Segoe UI", system-ui, sans-serif';
    const maxH = Math.floor((H - 100 - highestY) / HEIGHT_SCORE_DIVISOR);
    ctx.fillText('Max Height: ' + maxH, W / 2, H * 0.55);

    if (score >= bestScore && score > 0 && score > prevBestScore) {
      ctx.fillStyle = '#F9CA24';
      ctx.font = 'bold 24px "Avenir Next", "Segoe UI", system-ui, sans-serif';
      ctx.shadowColor = '#F9CA24';
      ctx.shadowBlur = 15;
      ctx.fillText('NEW BEST!', W / 2, H * 0.22);
      ctx.shadowBlur = 0;
    }

    ctx.fillStyle = '#FD79A8';
    roundRect(W / 2 - 90, H * 0.60, 180, 50, 25);
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 20px "Avenir Next", "Segoe UI", system-ui, sans-serif';
    ctx.fillText('Play Again', W / 2, H * 0.60 + 32);

    ctx.globalAlpha = 1;
  }

  function roundRect(x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    ctx.fill();
  }

  function isMuteIconClick(cx, cy) {
    const rect = canvas.getBoundingClientRect();
    const x = (cx - rect.left) * (W / rect.width);
    const y = (cy - rect.top) * (H / rect.height);
    const dx = x - MUTE_CX, dy = y - MUTE_CY;
    return dx * dx + dy * dy <= (MUTE_R + 4) * (MUTE_R + 4);
  }

  function toggleMute() {
    muted = !muted;
    localStorage.setItem('ballbounce_muted', muted ? 'true' : 'false');
  }

  canvas.addEventListener('mousemove', e => {
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (W / rect.width);
    const y = (e.clientY - rect.top) * (H / rect.height);
    const dx = x - MUTE_CX, dy = y - MUTE_CY;
    muteHovered = dx * dx + dy * dy <= (MUTE_R + 4) * (MUTE_R + 4);
    canvas.style.cursor = muteHovered ? 'pointer' : 'default';
  });
  canvas.addEventListener('mouseleave', () => { muteHovered = false; });

  function gameLoop(ts) {
    const dt = Math.min((ts - lastTime) / 1000, 0.05);
    lastTime = ts;

    if (state === 'playing' && paused) {
      if (shakeMag > 0.1) shakeMag *= 0.85; else shakeMag = 0;
      if (flashAlpha > 0.005) flashAlpha *= 0.9; else { flashAlpha = 0; flashColor = null; }
    }

    update(dt);

    if (state === 'title') renderTitle();
    else if (state === 'playing') {
      render();
      if (paused) renderPauseOverlay();
    }
    else renderGameOver();

    requestAnimationFrame(gameLoop);
  }

  let touchX = null;
  canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    const touch = e.touches[0];
    if (isMuteIconClick(touch.clientX, touch.clientY)) { toggleMute(); return; }
    if (state !== 'playing') { tap(); return; }
    if (paused) return;
    const rect = canvas.getBoundingClientRect();
    const x = touch.clientX - rect.left;
    inputDir = x < rect.width / 2 ? -1 : 1;
  }, { passive: false });

  canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    if (state !== 'playing' || paused) return;
    const rect = canvas.getBoundingClientRect();
    const x = e.touches[0].clientX - rect.left;
    inputDir = x < rect.width / 2 ? -1 : 1;
  }, { passive: false });

  canvas.addEventListener('touchend', e => { e.preventDefault(); inputDir = 0; }, { passive: false });

  canvas.addEventListener('mousedown', e => {
    if (isMuteIconClick(e.clientX, e.clientY)) { toggleMute(); return; }
    if (state !== 'playing') { tap(); return; }
    if (paused) return;
    const rect = canvas.getBoundingClientRect();
    inputDir = e.clientX - rect.left < rect.width / 2 ? -1 : 1;
  });
  canvas.addEventListener('mouseup', () => { inputDir = 0; });

  const keys = {};
  document.addEventListener('keydown', e => {
    if (e.code === 'KeyP') { if (state === 'playing') { paused = !paused; } return; }
    if (e.code === 'KeyM') { initAudio(); toggleMute(); return; }
    if (e.code === 'Space') { e.preventDefault(); if (!paused) tap(); return; }
    keys[e.code] = true;
    updateKeyInput();
  });
  document.addEventListener('keyup', e => { keys[e.code] = false; updateKeyInput(); });

  function updateKeyInput() {
    if (paused) return;
    const l = keys['ArrowLeft'] || keys['KeyA'];
    const r = keys['ArrowRight'] || keys['KeyD'];
    if (l && !r) inputDir = -1;
    else if (r && !l) inputDir = 1;
    else inputDir = 0;
  }

  init();
  requestAnimationFrame(gameLoop);
})();
</script>
</body>
</html>