<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>2048</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  html, body { height: 100%; overflow: hidden; touch-action: manipulation; }
  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
    background: #FAF8EF;
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    user-select: none; -webkit-user-select: none;
  }
  .home-link { position: fixed; top: 12px; left: 12px; color: #776E65; text-decoration: none; font-size: 0.85rem; z-index: 10; }
  .home-link:hover { color: #2D3436; }

  .container { width: 90vmin; max-width: 400px; }

  /* Header */
  .header { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 16px; padding: 0 4px; }
  .title { font-size: clamp(2rem, 8vw, 3rem); font-weight: 900; color: #776E65; }
  .scores { display: flex; gap: 8px; }
  .score-box {
    background: #BBADA0; border-radius: 6px; padding: 6px 16px; text-align: center; min-width: 70px;
  }
  .score-box .label { font-size: 0.65rem; color: #EEE4DA; font-weight: 700; text-transform: uppercase; letter-spacing: 1px; }
  .score-box .val { font-size: 1.2rem; color: #fff; font-weight: 900; }

  /* Grid */
  .grid-wrap {
    background: #BBADA0; border-radius: 12px; padding: 10px; position: relative;
    aspect-ratio: 1; width: 100%;
  }
  .grid {
    display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px;
    width: 100%; height: 100%;
  }
  .cell { background: rgba(238, 228, 218, 0.35); border-radius: 8px; }
  .tile-layer {
    position: absolute; top: 10px; left: 10px; right: 10px; bottom: 10px;
    pointer-events: none;
  }
  .tile {
    position: absolute; display: flex; align-items: center; justify-content: center;
    font-weight: 900; border-radius: 8px;
    transition: top 0.15s ease-in-out, left 0.15s ease-in-out;
  }
  .tile.new { animation: popIn 0.2s ease-out; }
  .tile.merged { animation: popMerge 0.2s ease-out; }
  @keyframes popIn { 0% { transform: scale(0); } 100% { transform: scale(1); } }
  @keyframes popMerge { 0% { transform: scale(1); } 50% { transform: scale(1.15); } 100% { transform: scale(1); } }

  /* Overlays */
  .overlay {
    position: absolute; top: 0; left: 0; right: 0; bottom: 0; border-radius: 12px;
    display: none; flex-direction: column; align-items: center; justify-content: center;
    z-index: 5;
  }
  .overlay.active { display: flex; }
  .overlay-title { background: rgba(250, 248, 239, 0.85); }
  .overlay-gameover { background: rgba(238, 228, 218, 0.73); }
  .overlay-win { background: rgba(237, 194, 46, 0.5); }
  .overlay h2 { font-size: clamp(1.8rem, 6vw, 2.5rem); color: #776E65; margin-bottom: 8px; }
  .overlay p { color: #776E65; font-size: 0.95rem; margin-bottom: 20px; }
  .overlay button {
    padding: 12px 36px; font-size: 1rem; font-weight: 700; border: none; border-radius: 8px;
    background: #8F7A66; color: #fff; cursor: pointer;
    transition: background 0.2s;
  }
  .overlay button:hover { background: #776E65; }
  .overlay button + button { margin-top: 8px; }

  .instructions { margin-top: 16px; font-size: 0.8rem; color: #776E65; text-align: center; padding: 0 8px; }
</style>
</head>
<body>
<a class="home-link" href="index.html">&#8592; Games</a>
<div class="container">
  <div class="header">
    <div class="title">2048</div>
    <div class="scores">
      <div class="score-box"><div class="label">Score</div><div class="val" id="score">0</div></div>
      <div class="score-box"><div class="label">Best</div><div class="val" id="best">0</div></div>
    </div>
  </div>
  <div class="grid-wrap" id="grid-wrap">
    <div class="grid" id="grid"></div>
    <div class="tile-layer" id="tile-layer"></div>

    <div class="overlay overlay-title active" id="overlay-title">
      <h2>2048</h2>
      <p>Swipe or use arrow keys to merge tiles</p>
      <button id="btn-start">Play</button>
    </div>
    <div class="overlay overlay-gameover" id="overlay-gameover">
      <h2>Game Over</h2>
      <p id="final-score-text">Score: 0</p>
      <button id="btn-retry">Play Again</button>
    </div>
    <div class="overlay overlay-win" id="overlay-win">
      <h2>You Win!</h2>
      <p>You reached 2048!</p>
      <button id="btn-continue">Keep Playing</button>
      <button id="btn-new">New Game</button>
    </div>
  </div>
  <p class="instructions">Swipe or use arrow keys. Merge tiles to reach 2048!</p>
</div>

<script>
(() => {
  const SIZE = 4;
  const LS_KEY = '2048_best';

  const scoreEl = document.getElementById('score');
  const bestEl = document.getElementById('best');
  const gridEl = document.getElementById('grid');
  const tileLayer = document.getElementById('tile-layer');
  const overlayTitle = document.getElementById('overlay-title');
  const overlayOver = document.getElementById('overlay-gameover');
  const overlayWin = document.getElementById('overlay-win');
  const finalScoreText = document.getElementById('final-score-text');

  let grid, score, bestScore, won, moving;

  // --- Web Audio Sound System ---
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  let actx;
  function initAudio() { if (!actx) actx = new AudioCtx(); if (actx.state === 'suspended') actx.resume(); }
  function tone(freq, dur, type, vol) { if (!actx) return; const o = actx.createOscillator(), g = actx.createGain(); o.type = type || 'sine'; o.frequency.setValueAtTime(freq, actx.currentTime); g.gain.setValueAtTime(vol || 0.3, actx.currentTime); g.gain.exponentialRampToValueAtTime(0.001, actx.currentTime + dur); o.connect(g); g.connect(actx.destination); o.start(); o.stop(actx.currentTime + dur); }
  function sweep(f1, f2, dur, type, vol) { if (!actx) return; const o = actx.createOscillator(), g = actx.createGain(); o.type = type || 'sine'; o.frequency.setValueAtTime(f1, actx.currentTime); o.frequency.exponentialRampToValueAtTime(f2, actx.currentTime + dur); g.gain.setValueAtTime(vol || 0.3, actx.currentTime); g.gain.exponentialRampToValueAtTime(0.001, actx.currentTime + dur); o.connect(g); g.connect(actx.destination); o.start(); o.stop(actx.currentTime + dur); }
  function sndSlide() { tone(250, 0.05, 'square', 0.1); }
  function sndMerge() { tone(520, 0.08, 'sine', 0.2); }
  function sndBigMerge() { tone(520, 0.08, 'sine', 0.25); setTimeout(() => tone(780, 0.12, 'sine', 0.3), 70); }
  function sndGameOver() { sweep(300, 80, 0.5, 'sawtooth', 0.2); }

  const COLORS = {
    2:    { bg: '#EEE4DA', fg: '#776E65' },
    4:    { bg: '#EDE0C8', fg: '#776E65' },
    8:    { bg: '#F2B179', fg: '#F9F6F2' },
    16:   { bg: '#F59563', fg: '#F9F6F2' },
    32:   { bg: '#F67C5F', fg: '#F9F6F2' },
    64:   { bg: '#F65E3B', fg: '#F9F6F2' },
    128:  { bg: '#EDCF72', fg: '#F9F6F2' },
    256:  { bg: '#EDCC61', fg: '#F9F6F2' },
    512:  { bg: '#EDC850', fg: '#F9F6F2' },
    1024: { bg: '#EDC53F', fg: '#F9F6F2' },
    2048: { bg: '#EDC22E', fg: '#F9F6F2' },
  };

  function getColor(val) {
    return COLORS[val] || { bg: '#3C3A32', fg: '#F9F6F2' };
  }

  function fontSize(val) {
    if (val < 100) return 'clamp(1.6rem, 7vmin, 2.2rem)';
    if (val < 1000) return 'clamp(1.3rem, 5.5vmin, 1.8rem)';
    if (val < 10000) return 'clamp(1rem, 4.5vmin, 1.4rem)';
    return 'clamp(0.8rem, 3.5vmin, 1.1rem)';
  }

  // Build static grid cells
  for (let i = 0; i < SIZE * SIZE; i++) {
    const cell = document.createElement('div');
    cell.className = 'cell';
    gridEl.appendChild(cell);
  }

  function init() {
    grid = Array.from({ length: SIZE }, () => Array(SIZE).fill(0));
    score = 0;
    won = false;
    moving = false;
    bestScore = parseInt(localStorage.getItem(LS_KEY) || '0');
    bestEl.textContent = bestScore;
    scoreEl.textContent = '0';
    addRandom();
    addRandom();
    renderTiles();
  }

  function addRandom() {
    const empty = [];
    for (let r = 0; r < SIZE; r++)
      for (let c = 0; c < SIZE; c++)
        if (grid[r][c] === 0) empty.push({ r, c });
    if (empty.length === 0) return;
    const cell = empty[Math.floor(Math.random() * empty.length)];
    grid[cell.r][cell.c] = Math.random() < 0.9 ? 2 : 4;
    return cell;
  }

  function slideRow(row) {
    let merged = 0;
    const filtered = row.filter(v => v !== 0);
    const result = [];
    for (let i = 0; i < filtered.length; i++) {
      if (i < filtered.length - 1 && filtered[i] === filtered[i + 1]) {
        const val = filtered[i] * 2;
        result.push(val);
        merged += val;
        i++; // skip next
      } else {
        result.push(filtered[i]);
      }
    }
    while (result.length < SIZE) result.push(0);
    return { result, merged };
  }

  function move(direction) {
    if (moving) return;
    let moved = false;
    let totalMerged = 0;
    const newGrid = grid.map(r => [...r]);

    function getRow(r, c, dir) {
      switch (dir) {
        case 'left': return newGrid[r];
        case 'right': return [...newGrid[r]].reverse();
        case 'up': return newGrid.map(row => row[c]);
        case 'down': return newGrid.map(row => row[c]).reverse();
      }
    }

    function setRow(r, c, dir, vals) {
      switch (dir) {
        case 'left': newGrid[r] = vals; break;
        case 'right': newGrid[r] = [...vals].reverse(); break;
        case 'up': vals.forEach((v, i) => newGrid[i][c] = v); break;
        case 'down': vals.forEach((v, i) => newGrid[SIZE - 1 - i][c] = v); break;
      }
    }

    const isRow = direction === 'left' || direction === 'right';
    const count = SIZE;

    for (let i = 0; i < count; i++) {
      const row = isRow ? getRow(i, 0, direction) : getRow(0, i, direction);
      const { result, merged } = slideRow(row);
      totalMerged += merged;

      // Check if changed
      const origRow = isRow ? getRow(i, 0, direction) : getRow(0, i, direction);
      if (result.some((v, idx) => v !== origRow[idx])) moved = true;

      if (isRow) setRow(i, 0, direction, result);
      else setRow(0, i, direction, result);
    }

    if (!moved) return;

    sndSlide();
    if (totalMerged >= 256) sndBigMerge();
    else if (totalMerged > 0) sndMerge();

    grid = newGrid;
    score += totalMerged;
    scoreEl.textContent = score;
    if (score > bestScore) {
      bestScore = score;
      bestEl.textContent = bestScore;
      localStorage.setItem(LS_KEY, bestScore);
    }

    moving = true;
    renderTiles();

    setTimeout(() => {
      const newCell = addRandom();
      renderTiles(newCell);
      moving = false;

      // Check win
      if (!won) {
        for (let r = 0; r < SIZE; r++)
          for (let c = 0; c < SIZE; c++)
            if (grid[r][c] === 2048) { won = true; overlayWin.classList.add('active'); return; }
      }

      // Check game over
      if (isGameOver()) {
        sndGameOver();
        finalScoreText.textContent = 'Score: ' + score;
        overlayOver.classList.add('active');
      }
    }, 160);
  }

  function isGameOver() {
    for (let r = 0; r < SIZE; r++)
      for (let c = 0; c < SIZE; c++) {
        if (grid[r][c] === 0) return false;
        if (c < SIZE - 1 && grid[r][c] === grid[r][c + 1]) return false;
        if (r < SIZE - 1 && grid[r][c] === grid[r + 1][c]) return false;
      }
    return true;
  }

  function renderTiles(newCell) {
    tileLayer.innerHTML = '';
    const layerRect = tileLayer.getBoundingClientRect();
    const gap = 10;
    const cellSize = (layerRect.width - gap * (SIZE - 1)) / SIZE;

    for (let r = 0; r < SIZE; r++) {
      for (let c = 0; c < SIZE; c++) {
        const val = grid[r][c];
        if (val === 0) continue;

        const tile = document.createElement('div');
        tile.className = 'tile';
        if (newCell && newCell.r === r && newCell.c === c) tile.classList.add('new');

        const color = getColor(val);
        tile.style.width = cellSize + 'px';
        tile.style.height = cellSize + 'px';
        tile.style.left = c * (cellSize + gap) + 'px';
        tile.style.top = r * (cellSize + gap) + 'px';
        tile.style.background = color.bg;
        tile.style.color = color.fg;
        tile.style.fontSize = fontSize(val);
        tile.textContent = val;

        if (val === 2048) {
          tile.style.boxShadow = '0 0 20px 5px rgba(237, 194, 46, 0.5)';
        }

        tileLayer.appendChild(tile);
      }
    }
  }

  // Swipe detection
  let touchStartX, touchStartY;
  const gridWrap = document.getElementById('grid-wrap');

  gridWrap.addEventListener('touchstart', e => {
    if (moving) return;
    touchStartX = e.touches[0].clientX;
    touchStartY = e.touches[0].clientY;
  }, { passive: true });

  gridWrap.addEventListener('touchend', e => {
    if (touchStartX == null) return;
    const dx = e.changedTouches[0].clientX - touchStartX;
    const dy = e.changedTouches[0].clientY - touchStartY;
    touchStartX = null;
    if (Math.max(Math.abs(dx), Math.abs(dy)) < 30) return;
    if (Math.abs(dx) > Math.abs(dy)) move(dx > 0 ? 'right' : 'left');
    else move(dy > 0 ? 'down' : 'up');
  }, { passive: true });

  document.addEventListener('keydown', e => {
    const map = { ArrowUp: 'up', ArrowDown: 'down', ArrowLeft: 'left', ArrowRight: 'right', KeyW: 'up', KeyS: 'down', KeyA: 'left', KeyD: 'right' };
    if (map[e.code]) { e.preventDefault(); move(map[e.code]); }
  });

  // Buttons
  document.getElementById('btn-start').addEventListener('click', () => {
    initAudio();
    overlayTitle.classList.remove('active');
    init();
  });
  document.getElementById('btn-retry').addEventListener('click', () => {
    overlayOver.classList.remove('active');
    init();
  });
  document.getElementById('btn-continue').addEventListener('click', () => {
    overlayWin.classList.remove('active');
  });
  document.getElementById('btn-new').addEventListener('click', () => {
    overlayWin.classList.remove('active');
    init();
  });

  // Load best score on start
  bestScore = parseInt(localStorage.getItem(LS_KEY) || '0');
  bestEl.textContent = bestScore;
})();
</script>
</body>
</html>
