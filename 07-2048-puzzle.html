<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>2048</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  html, body { height: 100%; overflow: hidden; touch-action: manipulation; }
  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
    background: linear-gradient(160deg, #FAF8EF 0%, #F0E6D3 40%, #E8DFC8 70%, #FAF8EF 100%);
    background-size: 400% 400%;
    animation: bgShift 20s ease infinite;
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    user-select: none; -webkit-user-select: none;
  }
  .home-link { position: fixed; top: 12px; left: 12px; color: rgba(119,110,101,0.7); text-decoration: none; font-family: system-ui, sans-serif; font-size: 0.8rem; z-index: 10; backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px); background: rgba(0,0,0,0.08); padding: 6px 14px; border-radius: 20px; transition: background 0.2s, color 0.2s; }
  .home-link:hover { color: #2D3436; background: rgba(0,0,0,0.15); }

  .mute-toggle {
    position: fixed; top: 12px; right: 12px; z-index: 10;
    background: rgba(0,0,0,0.08); border: none; cursor: pointer;
    opacity: 0.7; transition: opacity 0.2s, background 0.2s;
    line-height: 1; padding: 0;
    width: 40px; height: 40px; border-radius: 50%;
    display: flex; align-items: center; justify-content: center;
    backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
  }
  .mute-toggle:hover { opacity: 1; background: rgba(0,0,0,0.15); }
  .mute-toggle svg { display: block; }
  .mute-toggle[title]:hover::after {
    content: attr(title);
    position: absolute; top: 48px; right: 0;
    background: rgba(0,0,0,0.7); color: #fff;
    font-size: 12px; font-family: system-ui, sans-serif;
    padding: 4px 10px; border-radius: 6px; white-space: nowrap;
    pointer-events: none;
  }

  .container { width: 90vmin; max-width: 400px; }

  /* Header */
  .header { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 16px; padding: 0 4px; }
  .title { font-size: clamp(2rem, 8vw, 3rem); font-weight: 900; color: #776E65; }
  .scores { display: flex; gap: 8px; }
  .score-box {
    background: #BBADA0; border-radius: 6px; padding: 6px 16px; text-align: center; min-width: 70px;
  }
  .score-box .label { font-size: 0.65rem; color: #EEE4DA; font-weight: 700; text-transform: uppercase; letter-spacing: 1px; }
  .score-box .val { font-size: 1.2rem; color: #fff; font-weight: 900; }

  /* Buttons row */
  .btn-row { display: flex; gap: 8px; margin-bottom: 10px; padding: 0 4px; }
  .btn-row button {
    padding: 6px 16px; font-size: 0.8rem; font-weight: 700; border: none; border-radius: 6px;
    background: #8F7A66; color: #fff; cursor: pointer; transition: background 0.2s;
  }
  .btn-row button:hover { background: #776E65; }
  .btn-row button:disabled { opacity: 0.4; cursor: default; }

  /* Grid */
  .grid-wrap {
    background: #BBADA0; border-radius: 12px; padding: 10px; position: relative;
    aspect-ratio: 1; width: 100%;
  }
  .grid {
    display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px;
    width: 100%; height: 100%;
  }
  .cell { background: rgba(238, 228, 218, 0.35); border-radius: 8px; }
  .tile-layer {
    position: absolute; top: 10px; left: 10px; right: 10px; bottom: 10px;
    pointer-events: none;
  }
  .tile {
    position: absolute; display: flex; align-items: center; justify-content: center;
    font-weight: 900; border-radius: 8px;
    transition: top 0.15s ease-in-out, left 0.15s ease-in-out;
  }
  .tile.new { animation: popIn 0.2s ease-out; }
  .tile.merged { animation: bounceMerge 0.3s ease-out; }
  @keyframes bgShift {
    0% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
    100% { background-position: 0% 50%; }
  }
  @keyframes popIn { 0% { transform: scale(0); } 100% { transform: scale(1); } }
  @keyframes bounceMerge {
    0% { transform: scale(1); }
    30% { transform: scale(1.22); }
    60% { transform: scale(0.95); }
    100% { transform: scale(1); }
  }

  /* Floating score text */
  .float-score {
    position: absolute; pointer-events: none; z-index: 6;
    font-weight: 900; font-size: 1.1rem; color: #776E65;
    animation: floatUp 0.7s ease-out forwards;
    text-shadow: 0 1px 2px rgba(0,0,0,0.1);
  }
  @keyframes floatUp {
    0% { opacity: 1; transform: translateY(0) scale(1); }
    100% { opacity: 0; transform: translateY(-50px) scale(1.3); }
  }

  /* Milestone flash */
  .milestone-flash {
    position: absolute; top: 0; left: 0; right: 0; bottom: 0; border-radius: 12px;
    pointer-events: none; z-index: 4;
    animation: milestoneFlash 0.6s ease-out forwards;
  }
  @keyframes milestoneFlash {
    0% { background: rgba(237, 197, 63, 0.4); }
    100% { background: rgba(237, 197, 63, 0); }
  }

  /* Milestone text */
  .milestone-text {
    position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
    pointer-events: none; z-index: 7;
    font-weight: 900; font-size: clamp(1.4rem, 5vw, 2rem); color: #EDC53F;
    text-shadow: 0 2px 8px rgba(0,0,0,0.15);
    animation: milestonePopFade 1.2s ease-out forwards;
    white-space: nowrap;
  }
  @keyframes milestonePopFade {
    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
    20% { opacity: 1; transform: translate(-50%, -50%) scale(1.15); }
    40% { transform: translate(-50%, -50%) scale(1); }
    80% { opacity: 1; }
    100% { opacity: 0; transform: translate(-50%, -70%) scale(1); }
  }

  /* NEW BEST celebration */
  .new-best-text {
    position: absolute; top: 35%; left: 50%; transform: translate(-50%, -50%);
    pointer-events: none; z-index: 8;
    font-weight: 900; font-size: clamp(1.6rem, 6vw, 2.4rem);
    background: linear-gradient(135deg, #FFD700, #FFA500, #FFD700);
    -webkit-background-clip: text; -webkit-text-fill-color: transparent;
    background-clip: text;
    text-shadow: none;
    animation: newBestPop 1.5s ease-out forwards;
    white-space: nowrap;
    filter: drop-shadow(0 2px 6px rgba(255, 165, 0, 0.4));
  }
  @keyframes newBestPop {
    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.3) rotate(-5deg); }
    15% { opacity: 1; transform: translate(-50%, -50%) scale(1.2) rotate(2deg); }
    30% { transform: translate(-50%, -50%) scale(1) rotate(0deg); }
    75% { opacity: 1; }
    100% { opacity: 0; transform: translate(-50%, -70%) scale(0.9); }
  }

  /* Gold particles */
  .gold-particle {
    position: absolute; pointer-events: none; z-index: 8;
    width: 6px; height: 6px; border-radius: 50%;
    background: #FFD700;
    animation: particleBurst 1s ease-out forwards;
  }
  @keyframes particleBurst {
    0% { opacity: 1; transform: translate(0, 0) scale(1); }
    100% { opacity: 0; transform: translate(var(--px), var(--py)) scale(0); }
  }

  /* Overlays */
  .overlay {
    position: absolute; top: 0; left: 0; right: 0; bottom: 0; border-radius: 12px;
    display: none; flex-direction: column; align-items: center; justify-content: center;
    z-index: 5;
  }
  .overlay.active { display: flex; }
  .overlay-title { background: rgba(250, 248, 239, 0.85); }
  .overlay-gameover { background: rgba(238, 228, 218, 0.73); }
  .overlay-win { background: rgba(237, 194, 46, 0.5); }
  .overlay h2 { font-size: clamp(1.8rem, 6vw, 2.5rem); color: #776E65; margin-bottom: 8px; }
  .overlay p { color: #776E65; font-size: 0.95rem; margin-bottom: 20px; }
  .overlay button {
    padding: 12px 36px; font-size: 1rem; font-weight: 700; border: none; border-radius: 8px;
    background: #8F7A66; color: #fff; cursor: pointer;
    transition: background 0.2s;
  }
  .overlay button:hover { background: #776E65; }
  .overlay button + button { margin-top: 8px; }

  .instructions { margin-top: 16px; font-size: 0.8rem; color: #776E65; text-align: center; padding: 0 8px; line-height: 1.5; }
</style>
</head>
<body>
<a class="home-link" href="index.html">&#8592; Games</a>
<button class="mute-toggle" id="mute-toggle" title="Toggle sound (M)"></button>
<div class="container">
  <div class="header">
    <div class="title">2048</div>
    <div class="scores">
      <div class="score-box"><div class="label">Score</div><div class="val" id="score">0</div></div>
      <div class="score-box"><div class="label">Best</div><div class="val" id="best">0</div></div>
    </div>
  </div>
  <div class="btn-row">
    <button id="btn-undo" disabled title="Undo (U)">&#x21A9; Undo (1)</button>
    <button id="btn-newgame" title="New Game (N)">New Game</button>
  </div>
  <div class="grid-wrap" id="grid-wrap">
    <div class="grid" id="grid"></div>
    <div class="tile-layer" id="tile-layer"></div>

    <div class="overlay overlay-title active" id="overlay-title">
      <h2>2048</h2>
      <p>Swipe or use arrow keys to merge tiles</p>
      <button id="btn-start">Play</button>
    </div>
    <div class="overlay overlay-gameover" id="overlay-gameover">
      <h2>Game Over</h2>
      <p id="final-score-text">Score: 0</p>
      <p id="final-stats-text" style="font-size: 0.8rem; color: #8F7A66; margin-bottom: 16px;"></p>
      <button id="btn-retry">Play Again</button>
    </div>
    <div class="overlay overlay-win" id="overlay-win">
      <h2>You Win!</h2>
      <p>You reached 2048!</p>
      <button id="btn-continue">Keep Playing</button>
      <button id="btn-new">New Game</button>
    </div>
  </div>
  <p class="instructions">Swipe or arrow keys to slide. Merge tiles to reach 2048!<br>Press <strong>M</strong> to mute, <strong>U</strong> to undo, <strong>N</strong> for new game.</p>
</div>

<script>
(() => {
  /**
   * 2048 Puzzle — Tile-merging number puzzle
   * Slide tiles to merge matching numbers and reach 2048.
   *
   * Controls: Swipe / Arrow Keys to slide, U to undo, N for new game, M to mute
   * Rendering: DOM + CSS transitions
   * State machine: title → playing → gameover / win
   */

  // === CONFIGURATION ===
  const SIZE = 4;
  const LS_KEY = '2048_best';
  const LS_MUTE = '2048_muted';
  // Milestones
  const MILESTONE_INTERVAL = 5000;
  // Big merge threshold
  const BIG_MERGE_THRESHOLD = 256;
  // Tile spawn delay (ms)
  const TILE_SPAWN_DELAY = 160;
  // Swipe threshold (px)
  const SWIPE_THRESHOLD = 30;
  // Score animation
  const SCORE_ANIM_MIN_DURATION = 120;
  const SCORE_ANIM_MAX_DURATION = 400;
  const SCORE_ANIM_DURATION_FACTOR = 2;
  // New game particles
  const NEW_GAME_PARTICLE_COUNT = 12;
  const PARTICLE_DIST_MIN = 50;
  const PARTICLE_DIST_RANGE = 60;
  // Audio
  const AUDIO_FADEOUT = 0.001;

  const scoreEl = document.getElementById('score');
  const bestEl = document.getElementById('best');
  const gridEl = document.getElementById('grid');
  const tileLayer = document.getElementById('tile-layer');
  const gridWrap = document.getElementById('grid-wrap');
  const overlayTitle = document.getElementById('overlay-title');
  const overlayOver = document.getElementById('overlay-gameover');
  const overlayWin = document.getElementById('overlay-win');
  const finalScoreText = document.getElementById('final-score-text');
  const muteBtn = document.getElementById('mute-toggle');
  const undoBtn = document.getElementById('btn-undo');

  let grid, score, bestScore, won, moving;
  let displayedScore = 0;
  let scoreAnimFrame = null;
  let prevState = null; // for undo: { grid, score }
  let hasUndone = false;
  let newBestShown = false;
  let lastMilestone = 0;
  let moveCount = 0;
  let mergeCount = 0;

  // --- Mute System ---
  let muted = localStorage.getItem(LS_MUTE) === '1';
  function updateMuteIcon() {
    muteBtn.title = muted ? 'Unmute (M)' : 'Mute (M)';
    muteBtn.innerHTML = muted
      ? '<svg width="24" height="20" viewBox="0 0 24 20"><rect x="0" y="6" width="6" height="8" rx="1" fill="#776E65"/><polygon points="6,6 12,1 12,19 6,14" fill="#776E65"/><line x1="15" y1="5" x2="22" y2="15" stroke="#E74C3C" stroke-width="2.5" stroke-linecap="round"/><line x1="22" y1="5" x2="15" y2="15" stroke="#E74C3C" stroke-width="2.5" stroke-linecap="round"/></svg>'
      : '<svg width="24" height="20" viewBox="0 0 24 20"><rect x="0" y="6" width="6" height="8" rx="1" fill="#776E65"/><polygon points="6,6 12,1 12,19 6,14" fill="#776E65"/><path d="M14 7.5 A3.5 3.5 0 0 1 14 12.5" fill="none" stroke="#776E65" stroke-width="1.8" stroke-linecap="round"/><path d="M16 4 A7 7 0 0 1 16 16" fill="none" stroke="#776E65" stroke-width="1.8" stroke-linecap="round"/></svg>';
  }
  updateMuteIcon();
  muteBtn.addEventListener('click', () => {
    muted = !muted;
    localStorage.setItem(LS_MUTE, muted ? '1' : '0');
    updateMuteIcon();
  });

  // === AUDIO ENGINE ===
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  let actx;

  function initAudio() {
    if (!actx) actx = new AudioCtx();
    if (actx.state === 'suspended') actx.resume();
  }

  function tone(freq, dur, type, vol) {
    if (!actx || muted) return;
    const o = actx.createOscillator();
    const g = actx.createGain();
    o.type = type || 'sine';
    o.frequency.setValueAtTime(freq, actx.currentTime);
    g.gain.setValueAtTime(vol || 0.3, actx.currentTime);
    g.gain.exponentialRampToValueAtTime(AUDIO_FADEOUT, actx.currentTime + dur);
    o.connect(g);
    g.connect(actx.destination);
    o.start();
    o.stop(actx.currentTime + dur);
  }

  function sweep(f1, f2, dur, type, vol) {
    if (!actx || muted) return;
    const o = actx.createOscillator();
    const g = actx.createGain();
    o.type = type || 'sine';
    o.frequency.setValueAtTime(f1, actx.currentTime);
    o.frequency.exponentialRampToValueAtTime(f2, actx.currentTime + dur);
    g.gain.setValueAtTime(vol || 0.3, actx.currentTime);
    g.gain.exponentialRampToValueAtTime(AUDIO_FADEOUT, actx.currentTime + dur);
    o.connect(g);
    g.connect(actx.destination);
    o.start();
    o.stop(actx.currentTime + dur);
  }

  // === SOUND EFFECTS ===
  // Slide — short low square click for tile movement
  function sndSlide() { tone(250, 0.05, 'square', 0.1); }
  // Merge — medium tone for standard tile merge
  function sndMerge() { tone(520, 0.08, 'sine', 0.2); }
  // Big Merge — two-tone ascending for high-value tile merges
  function sndBigMerge() { tone(520, 0.08, 'sine', 0.25); setTimeout(() => tone(780, 0.12, 'sine', 0.3), 70); }
  // Game Over — descending sawtooth sweep
  function sndGameOver() { sweep(300, 80, 0.5, 'sawtooth', 0.2); }
  function sndFanfare() {
    if (!actx || muted) return;
    tone(523, 0.15, 'sine', 0.25);
    setTimeout(() => tone(659, 0.15, 'sine', 0.25), 120);
    setTimeout(() => tone(784, 0.2, 'sine', 0.3), 240);
    setTimeout(() => tone(1047, 0.3, 'sine', 0.3), 380);
  }
  function sndMilestone() {
    if (!actx || muted) return;
    tone(660, 0.1, 'sine', 0.2);
    setTimeout(() => tone(880, 0.15, 'sine', 0.25), 100);
  }

  // --- Gradient Tile Colors ---
  const TILE_STYLES = {
    2:    { bg: 'linear-gradient(135deg, #EEE4DA, #E8DDD0)', fg: '#776E65' },
    4:    { bg: 'linear-gradient(135deg, #EDE0C8, #E4D5B5)', fg: '#776E65' },
    8:    { bg: 'linear-gradient(135deg, #F2B179, #E89A5A)', fg: '#F9F6F2' },
    16:   { bg: 'linear-gradient(135deg, #F59563, #E87D48)', fg: '#F9F6F2' },
    32:   { bg: 'linear-gradient(135deg, #F67C5F, #E55A3A)', fg: '#F9F6F2' },
    64:   { bg: 'linear-gradient(135deg, #F65E3B, #D94420)', fg: '#F9F6F2' },
    128:  { bg: 'linear-gradient(135deg, #EDCF72, #E0BC4A)', fg: '#F9F6F2' },
    256:  { bg: 'linear-gradient(135deg, #EDCC61, #D9B83E)', fg: '#F9F6F2' },
    512:  { bg: 'linear-gradient(135deg, #EDC850, #D4AD2E)', fg: '#F9F6F2', glow: '0 0 18px 4px rgba(237, 200, 80, 0.45)' },
    1024: { bg: 'linear-gradient(135deg, #EDC53F, #C9A420)', fg: '#F9F6F2', glow: '0 0 22px 6px rgba(237, 197, 63, 0.55)' },
    2048: { bg: 'linear-gradient(135deg, #EDC22E, #C49A10)', fg: '#F9F6F2', glow: '0 0 28px 8px rgba(237, 194, 46, 0.65)' },
  };

  function getTileStyle(val) {
    if (TILE_STYLES[val]) return TILE_STYLES[val];
    return { bg: 'linear-gradient(135deg, #3C3A32, #2A2826)', fg: '#F9F6F2', glow: '0 0 30px 8px rgba(60, 58, 50, 0.5)' };
  }

  function fontSize(val) {
    if (val < 100) return 'clamp(1.6rem, 7vmin, 2.2rem)';
    if (val < 1000) return 'clamp(1.3rem, 5.5vmin, 1.8rem)';
    if (val < 10000) return 'clamp(1rem, 4.5vmin, 1.4rem)';
    return 'clamp(0.8rem, 3.5vmin, 1.1rem)';
  }

  // Build static grid cells
  for (let i = 0; i < SIZE * SIZE; i++) {
    const cell = document.createElement('div');
    cell.className = 'cell';
    gridEl.appendChild(cell);
  }

  // --- Animated Score Counter ---
  function animateScore(target) {
    if (scoreAnimFrame) cancelAnimationFrame(scoreAnimFrame);
    const start = displayedScore;
    const diff = target - start;
    if (diff === 0) return;
    const duration = Math.min(SCORE_ANIM_MAX_DURATION, Math.max(SCORE_ANIM_MIN_DURATION, diff * SCORE_ANIM_DURATION_FACTOR));
    const startTime = performance.now();
    function step(now) {
      const elapsed = now - startTime;
      const t = Math.min(elapsed / duration, 1);
      const eased = 1 - Math.pow(1 - t, 3); // ease-out cubic
      displayedScore = Math.round(start + diff * eased);
      scoreEl.textContent = displayedScore;
      if (t < 1) {
        scoreAnimFrame = requestAnimationFrame(step);
      } else {
        displayedScore = target;
        scoreEl.textContent = target;
        scoreAnimFrame = null;
      }
    }
    scoreAnimFrame = requestAnimationFrame(step);
  }

  // --- Floating "+N" Text ---
  function showFloatingScore(value, r, c) {
    const layerRect = tileLayer.getBoundingClientRect();
    const gap = 10;
    const cellSize = (layerRect.width - gap * (SIZE - 1)) / SIZE;
    const x = c * (cellSize + gap) + cellSize / 2;
    const y = r * (cellSize + gap);

    const el = document.createElement('div');
    el.className = 'float-score';
    el.textContent = '+' + value;
    el.style.left = x + 'px';
    el.style.top = y + 'px';
    el.style.transform = 'translateX(-50%)';
    tileLayer.parentElement.appendChild(el);
    el.addEventListener('animationend', () => el.remove());
  }

  // --- Milestone Celebration ---
  function showMilestone(text) {
    // Flash
    const flash = document.createElement('div');
    flash.className = 'milestone-flash';
    gridWrap.appendChild(flash);
    flash.addEventListener('animationend', () => flash.remove());

    // Text
    const el = document.createElement('div');
    el.className = 'milestone-text';
    el.textContent = text;
    gridWrap.appendChild(el);
    el.addEventListener('animationend', () => el.remove());

    sndMilestone();
  }

  // --- NEW BEST Celebration ---
  function showNewBest() {
    const el = document.createElement('div');
    el.className = 'new-best-text';
    el.textContent = 'NEW BEST!';
    gridWrap.appendChild(el);
    el.addEventListener('animationend', () => el.remove());

    // Gold particles
    for (let i = 0; i < NEW_GAME_PARTICLE_COUNT; i++) {
      const p = document.createElement('div');
      p.className = 'gold-particle';
      const angle = (Math.PI * 2 / NEW_GAME_PARTICLE_COUNT) * i + (Math.random() - 0.5) * 0.5;
      const dist = PARTICLE_DIST_MIN + Math.random() * PARTICLE_DIST_RANGE;
      p.style.setProperty('--px', Math.cos(angle) * dist + 'px');
      p.style.setProperty('--py', Math.sin(angle) * dist + 'px');
      p.style.left = '50%';
      p.style.top = '35%';
      p.style.width = (4 + Math.random() * 4) + 'px';
      p.style.height = p.style.width;
      const colors = ['#FFD700', '#FFA500', '#FFE066', '#FFCC00'];
      p.style.background = colors[Math.floor(Math.random() * colors.length)];
      gridWrap.appendChild(p);
      p.addEventListener('animationend', () => p.remove());
    }

    sndFanfare();
  }

  // --- Undo System ---
  function saveState() {
    prevState = {
      grid: grid.map(r => [...r]),
      score: score
    };
    hasUndone = false;
    undoBtn.disabled = false;
    undoBtn.innerHTML = '&#x21A9; Undo (1)';
  }

  function performUndo() {
    if (!prevState || hasUndone || moving) return;
    grid = prevState.grid.map(r => [...r]);
    score = prevState.score;
    animateScore(score);
    hasUndone = true;
    undoBtn.disabled = true;
    undoBtn.innerHTML = '&#x21A9; Undo (0)';
    renderTiles();
  }

  undoBtn.addEventListener('click', () => {
    performUndo();
  });

  function init() {
    grid = Array.from({ length: SIZE }, () => Array(SIZE).fill(0));
    score = 0;
    displayedScore = 0;
    won = false;
    moving = false;
    prevState = null;
    hasUndone = false;
    newBestShown = false;
    lastMilestone = 0;
    moveCount = 0;
    mergeCount = 0;
    undoBtn.disabled = true;
    undoBtn.innerHTML = '&#x21A9; Undo (1)';
    bestScore = parseInt(localStorage.getItem(LS_KEY) || '0');
    bestEl.textContent = bestScore;
    scoreEl.textContent = '0';
    addRandom();
    addRandom();
    renderTiles();
  }

  function addRandom() {
    const empty = [];
    for (let r = 0; r < SIZE; r++)
      for (let c = 0; c < SIZE; c++)
        if (grid[r][c] === 0) empty.push({ r, c });
    if (empty.length === 0) return;
    const cell = empty[Math.floor(Math.random() * empty.length)];
    grid[cell.r][cell.c] = Math.random() < 0.9 ? 2 : 4;
    return cell;
  }

  function slideRow(row) {
    let merged = 0;
    const mergePositions = [];
    const filtered = row.filter(v => v !== 0);
    const result = [];
    let ri = 0;
    for (let i = 0; i < filtered.length; i++) {
      if (i < filtered.length - 1 && filtered[i] === filtered[i + 1]) {
        const val = filtered[i] * 2;
        result.push(val);
        merged += val;
        mergePositions.push({ idx: ri, val });
        i++;
      } else {
        result.push(filtered[i]);
      }
      ri++;
    }
    while (result.length < SIZE) result.push(0);
    return { result, merged, mergePositions };
  }

  function move(direction) {
    if (moving) return;
    let moved = false;
    let totalMerged = 0;
    const mergeInfo = []; // { r, c, val } for floating scores
    const mergedCells = new Set(); // "r,c" for bounce animation
    const newGrid = grid.map(r => [...r]);

    function getRow(r, c, dir) {
      switch (dir) {
        case 'left': return newGrid[r];
        case 'right': return [...newGrid[r]].reverse();
        case 'up': return newGrid.map(row => row[c]);
        case 'down': return newGrid.map(row => row[c]).reverse();
      }
    }

    function setRow(r, c, dir, vals) {
      switch (dir) {
        case 'left': newGrid[r] = vals; break;
        case 'right': newGrid[r] = [...vals].reverse(); break;
        case 'up': vals.forEach((v, i) => newGrid[i][c] = v); break;
        case 'down': vals.forEach((v, i) => newGrid[SIZE - 1 - i][c] = v); break;
      }
    }

    const isRow = direction === 'left' || direction === 'right';
    const count = SIZE;

    for (let i = 0; i < count; i++) {
      const row = isRow ? getRow(i, 0, direction) : getRow(0, i, direction);
      const { result, merged, mergePositions } = slideRow(row);
      totalMerged += merged;

      // Track merge positions for floating scores and bounce
      for (const mp of mergePositions) {
        let mr, mc;
        if (isRow) {
          mr = i;
          if (direction === 'left') mc = mp.idx;
          else mc = SIZE - 1 - mp.idx;
        } else {
          mc = i;
          if (direction === 'up') mr = mp.idx;
          else mr = SIZE - 1 - mp.idx;
        }
        mergeInfo.push({ r: mr, c: mc, val: mp.val });
        mergedCells.add(mr + ',' + mc);
      }

      const origRow = isRow ? getRow(i, 0, direction) : getRow(0, i, direction);
      if (result.some((v, idx) => v !== origRow[idx])) moved = true;

      if (isRow) setRow(i, 0, direction, result);
      else setRow(0, i, direction, result);
    }

    if (!moved) return;

    // Save state for undo (before this move's changes)
    saveState();

    moveCount++;
    mergeCount += mergeInfo.length;

    sndSlide();
    if (totalMerged >= BIG_MERGE_THRESHOLD) sndBigMerge();
    else if (totalMerged > 0) sndMerge();

    grid = newGrid;
    const oldScore = score;
    score += totalMerged;
    animateScore(score);

    // Check for new best
    if (score > bestScore) {
      const wasBest = bestScore;
      bestScore = score;
      bestEl.textContent = bestScore;
      localStorage.setItem(LS_KEY, bestScore);
      if (!newBestShown && wasBest > 0 && oldScore <= wasBest) {
        newBestShown = true;
        showNewBest();
      }
    }

    // Check milestones (every 5000 points)
    const currentMilestone = Math.floor(score / MILESTONE_INTERVAL);
    if (currentMilestone > lastMilestone && lastMilestone >= 0) {
      lastMilestone = currentMilestone;
      showMilestone(currentMilestone * MILESTONE_INTERVAL + ' points!');
    }

    moving = true;
    renderTiles(null, mergedCells);

    // Show floating merge scores
    for (const mi of mergeInfo) {
      showFloatingScore(mi.val, mi.r, mi.c);
    }

    setTimeout(() => {
      const newCell = addRandom();
      renderTiles(newCell, null);
      moving = false;

      // Check win
      if (!won) {
        for (let r = 0; r < SIZE; r++)
          for (let c = 0; c < SIZE; c++)
            if (grid[r][c] === 2048) { won = true; overlayWin.classList.add('active'); return; }
      }

      // Check game over
      if (isGameOver()) {
        sndGameOver();
        finalScoreText.textContent = 'Score: ' + score;
        let highestTile = 0;
        for (let r = 0; r < SIZE; r++)
          for (let c = 0; c < SIZE; c++)
            if (grid[r][c] > highestTile) highestTile = grid[r][c];
        document.getElementById('final-stats-text').textContent =
          'Highest Tile: ' + highestTile + '  |  Moves: ' + moveCount + '  |  Merges: ' + mergeCount;
        overlayOver.classList.add('active');
      }
    }, TILE_SPAWN_DELAY);
  }

  function isGameOver() {
    for (let r = 0; r < SIZE; r++)
      for (let c = 0; c < SIZE; c++) {
        if (grid[r][c] === 0) return false;
        if (c < SIZE - 1 && grid[r][c] === grid[r][c + 1]) return false;
        if (r < SIZE - 1 && grid[r][c] === grid[r + 1][c]) return false;
      }
    return true;
  }

  function renderTiles(newCell, mergedCells) {
    tileLayer.innerHTML = '';
    const layerRect = tileLayer.getBoundingClientRect();
    const gap = 10;
    const cellSize = (layerRect.width - gap * (SIZE - 1)) / SIZE;

    for (let r = 0; r < SIZE; r++) {
      for (let c = 0; c < SIZE; c++) {
        const val = grid[r][c];
        if (val === 0) continue;

        const tile = document.createElement('div');
        tile.className = 'tile';
        if (newCell && newCell.r === r && newCell.c === c) tile.classList.add('new');
        if (mergedCells && mergedCells.has(r + ',' + c)) tile.classList.add('merged');

        const style = getTileStyle(val);
        tile.style.width = cellSize + 'px';
        tile.style.height = cellSize + 'px';
        tile.style.left = c * (cellSize + gap) + 'px';
        tile.style.top = r * (cellSize + gap) + 'px';
        tile.style.background = style.bg;
        tile.style.color = style.fg;
        tile.style.fontSize = fontSize(val);
        tile.textContent = val;

        if (style.glow) {
          tile.style.boxShadow = style.glow;
        }

        tileLayer.appendChild(tile);
      }
    }
  }

  // Swipe detection
  let touchStartX, touchStartY;

  gridWrap.addEventListener('touchstart', e => {
    if (moving) return;
    touchStartX = e.touches[0].clientX;
    touchStartY = e.touches[0].clientY;
  }, { passive: true });

  gridWrap.addEventListener('touchend', e => {
    if (touchStartX == null) return;
    const dx = e.changedTouches[0].clientX - touchStartX;
    const dy = e.changedTouches[0].clientY - touchStartY;
    touchStartX = null;
    if (Math.max(Math.abs(dx), Math.abs(dy)) < SWIPE_THRESHOLD) return;
    if (Math.abs(dx) > Math.abs(dy)) move(dx > 0 ? 'right' : 'left');
    else move(dy > 0 ? 'down' : 'up');
  }, { passive: true });

  document.addEventListener('keydown', e => {
    const map = { ArrowUp: 'up', ArrowDown: 'down', ArrowLeft: 'left', ArrowRight: 'right', KeyW: 'up', KeyS: 'down', KeyA: 'left', KeyD: 'right' };
    if (map[e.code]) { e.preventDefault(); move(map[e.code]); }
    if (e.code === 'KeyM') {
      muted = !muted;
      localStorage.setItem(LS_MUTE, muted ? '1' : '0');
      updateMuteIcon();
    }
    if (e.code === 'KeyU') {
      performUndo();
    }
    if (e.code === 'KeyN') {
      overlayTitle.classList.remove('active');
      overlayOver.classList.remove('active');
      overlayWin.classList.remove('active');
      init();
    }
  });

  // Buttons
  document.getElementById('btn-start').addEventListener('click', () => {
    initAudio();
    overlayTitle.classList.remove('active');
    init();
  });
  document.getElementById('btn-retry').addEventListener('click', () => {
    overlayOver.classList.remove('active');
    init();
  });
  document.getElementById('btn-continue').addEventListener('click', () => {
    overlayWin.classList.remove('active');
  });
  document.getElementById('btn-new').addEventListener('click', () => {
    overlayWin.classList.remove('active');
    init();
  });
  document.getElementById('btn-newgame').addEventListener('click', () => {
    overlayTitle.classList.remove('active');
    overlayOver.classList.remove('active');
    overlayWin.classList.remove('active');
    init();
  });

  // Load best score on start
  bestScore = parseInt(localStorage.getItem(LS_KEY) || '0');
  bestEl.textContent = bestScore;
})();
</script>
</body>
</html>