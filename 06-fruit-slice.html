<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Fruit Slice</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  html, body { height: 100%; overflow: hidden; background: #2D3436; touch-action: manipulation; }
  body { display: flex; align-items: center; justify-content: center; }
  canvas { display: block; }
  .home-link { position: fixed; top: 12px; left: 12px; color: rgba(255,255,255,0.7); text-decoration: none; font-family: system-ui, sans-serif; font-size: 0.8rem; z-index: 10; backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px); background: rgba(0,0,0,0.25); padding: 6px 14px; border-radius: 20px; transition: background 0.2s, color 0.2s; }
  .home-link:hover { color: #fff; background: rgba(0,0,0,0.45); }
</style>
</head>
<body>
<a class="home-link" href="index.html">&#8592; Games</a>
<canvas id="c"></canvas>
<script>
(() => {
  /**
   * Fruit Slice — Swipe-to-slice fruit game
   * Swipe to slice fruits flying through the air. Avoid the bombs!
   *
   * Controls: Swipe/mouse drag to slice, P to pause, M to mute
   * Rendering: Canvas 2D, 400x700 internal resolution
   * State machine: title → playing → gameover
   */

  const W = 400, H = 700;
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  canvas.width = W * dpr; canvas.height = H * dpr;
  ctx.scale(dpr, dpr);

  function resize() {
    const a = W / H;
    let w = window.innerWidth, h = window.innerHeight;
    if (w / h > a) w = h * a; else h = w / a;
    canvas.style.width = w + 'px'; canvas.style.height = h + 'px';
  }
  window.addEventListener('resize', resize); resize();

  const GRAVITY = 600;
  const FRUIT_TYPES = [
    { name: 'watermelon', color: '#E74C3C', inner: '#FF6B6B', r: 28, leaf: true },
    { name: 'orange', color: '#E67E22', inner: '#F39C12', r: 24, leaf: false },
    { name: 'apple', color: '#2ECC71', inner: '#55EFC4', r: 22, leaf: true },
    { name: 'grape', color: '#9B59B6', inner: '#A29BFE', r: 20, leaf: false },
    { name: 'banana', color: '#F1C40F', inner: '#FFEAA7', r: 22, leaf: false },
  ];

  const FREEZE_TYPE = { name: 'freeze', color: '#74B9FF', inner: '#A3D8FF', r: 22, leaf: false, isFreeze: true };

  // === CONFIGURATION ===
  // Lives
  const MAX_MISSES = 3;
  // Combo
  const COMBO_TIMEOUT = 0.6;
  const CRITICAL_SLICE_THRESHOLD = 3;
  // Freeze power-up
  const FREEZE_DURATION = 3.0;
  const FREEZE_TIME_SCALE = 0.35;
  // Spawn timing
  const SPAWN_INTERVAL_MIN = 1.0;
  const SPAWN_INTERVAL_BASE = 2.2;
  const SPAWN_INTERVAL_DECAY = 0.08;
  const SPAWN_WAVE_DELAY = 150;
  const BOMB_MIN_WAVE = 3;
  const BOMB_CHANCE = 0.3;
  const FREEZE_MIN_WAVE = 5;
  const FREEZE_CHANCE = 0.12;
  const MAX_FRUITS_PER_WAVE = 6;
  const WAVE_COUNT_DIVISOR = 3;
  // Fruit velocities
  const FRUIT_VY_BASE = -700;
  const FRUIT_VY_RANGE = 300;
  const BOMB_VY_BASE = -750;
  const BOMB_VY_RANGE = 200;
  const FREEZE_VY_BASE = -720;
  const FREEZE_VY_RANGE = 250;
  const BOMB_RADIUS = 24;
  // Particles
  const PARTICLE_GRAVITY = 400;
  const PARTICLE_DECAY = 2;
  const SLICE_PARTICLE_COUNT = 18;
  const FREEZE_PARTICLE_COUNT = 20;
  const MILESTONE_PARTICLE_COUNT = 25;
  const CRITICAL_PARTICLE_COUNT = 20;
  const BOMB_EXPLOSION_COUNT = 40;
  const BOMB_SMOKE_COUNT = 15;
  const NEW_BEST_PARTICLE_COUNT = 40;
  const NEW_BEST_GRAVITY = 300;
  // Trail
  const TRAIL_MAX_LENGTH = 20;
  const TRAIL_DECAY = 4;
  // Floating text
  const FLOATING_TEXT_SPEED = -80;
  // Milestones
  const MILESTONE_INTERVAL = 25;
  // Screen effects
  const FLASH_INITIAL_ALPHA = 0.5;
  const BOMB_SHAKE_INTENSITY = 12;
  const BOMB_SHAKE_DURATION = 0.4;
  const MISS_SHAKE_INTENSITY = 8;
  const MISS_SHAKE_DURATION = 0.3;
  // Transitions
  const TRANSITION_DURATION = 0.3;
  const SLOW_MOTION_FACTOR = 0.25;
  const SLOW_MOTION_DURATION = 0.5;
  const GAME_OVER_FADE_SPEED = 3;
  // Audio
  const AUDIO_FADEOUT = 0.001;

  let state, score, bestScore, combo, comboTimer, misses, maxMisses;
  let fruits, halves, bombs, particles, trail, spawnTimer, lastTime;
  let waveCount;
  let floatingTexts;
  let paused;
  let shakeIntensity, shakeDuration, shakeTimer;
  let flashColor, flashAlpha, flashDuration, flashTimer;
  let newBestTriggered, newBestParticles;
  let lastMilestone;
  let freezeTimer, freezeActive;
  let swipeSliceCount;
  let totalSlices, bestCombo;

  // --- Screen Transition State ---
  let transitionAlpha = 0;
  let transitionTimer = 0;
  let slowMotion = false;
  let slowMotionTimer = 0;
  let gameOverFade = 0;
  let gameOverFading = false;

  // --- Mute ---
  let muted = localStorage.getItem('fruitslice_muted') === 'true';

  // === AUDIO ENGINE ===
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  let actx;

  function initAudio() {
    if (!actx) actx = new AudioCtx();
    if (actx.state === 'suspended') actx.resume();
  }

  function tone(freq, dur, type, vol) {
    if (!actx || muted) return;
    const o = actx.createOscillator();
    const g = actx.createGain();
    o.type = type || 'sine';
    o.frequency.setValueAtTime(freq, actx.currentTime);
    g.gain.setValueAtTime(vol || 0.3, actx.currentTime);
    g.gain.exponentialRampToValueAtTime(AUDIO_FADEOUT, actx.currentTime + dur);
    o.connect(g);
    g.connect(actx.destination);
    o.start();
    o.stop(actx.currentTime + dur);
  }

  function sweep(f1, f2, dur, type, vol) {
    if (!actx || muted) return;
    const o = actx.createOscillator();
    const g = actx.createGain();
    o.type = type || 'sine';
    o.frequency.setValueAtTime(f1, actx.currentTime);
    o.frequency.exponentialRampToValueAtTime(f2, actx.currentTime + dur);
    g.gain.setValueAtTime(vol || 0.3, actx.currentTime);
    g.gain.exponentialRampToValueAtTime(AUDIO_FADEOUT, actx.currentTime + dur);
    o.connect(g);
    g.connect(actx.destination);
    o.start();
    o.stop(actx.currentTime + dur);
  }

  function noise(dur, vol) {
    if (!actx || muted) return;
    const buf = actx.createBuffer(1, actx.sampleRate * dur | 0, actx.sampleRate);
    const data = buf.getChannelData(0);
    for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
    const src = actx.createBufferSource();
    const g = actx.createGain();
    src.buffer = buf;
    g.gain.setValueAtTime(vol || 0.15, actx.currentTime);
    g.gain.exponentialRampToValueAtTime(AUDIO_FADEOUT, actx.currentTime + dur);
    src.connect(g);
    g.connect(actx.destination);
    src.start();
  }

  // === SOUND EFFECTS ===
  // Slice — short noise burst + upward sweep for satisfying cut feel
  function sndSlice() { noise(0.06, 0.25); sweep(800, 1200, 0.08, 'sine', 0.2); }
  // Bomb — longer noise + downward sawtooth sweep for explosion
  function sndBomb() { noise(0.3, 0.35); sweep(200, 50, 0.4, 'sawtooth', 0.3); }
  // Combo — ascending three-tone arpeggio
  function sndCombo() { tone(660, 0.08, 'sine', 0.2); setTimeout(() => tone(880, 0.08, 'sine', 0.2), 60); setTimeout(() => tone(1100, 0.1, 'sine', 0.25), 120); }
  // Miss — descending sweep for a missed fruit
  function sndMiss() { sweep(300, 150, 0.2, 'sine', 0.15); }
  // Freeze — two high tones for activating freeze power-up
  function sndFreeze() { tone(1200, 0.15, 'sine', 0.2); setTimeout(() => tone(1600, 0.2, 'sine', 0.15), 80); }
  // Critical — four-note rising arpeggio for critical slice
  function sndCritical() { tone(880, 0.06, 'sine', 0.2); setTimeout(() => tone(1100, 0.06, 'sine', 0.2), 50); setTimeout(() => tone(1320, 0.06, 'sine', 0.2), 100); setTimeout(() => tone(1760, 0.12, 'sine', 0.3), 150); }
  // Milestone — four-note fanfare for score milestones
  function sndMilestone() { tone(523, 0.1, 'sine', 0.2); setTimeout(() => tone(659, 0.1, 'sine', 0.2), 80); setTimeout(() => tone(784, 0.1, 'sine', 0.2), 160); setTimeout(() => tone(1047, 0.15, 'sine', 0.25), 240); }
  // New Best — five-note ascending fanfare for new high score
  function sndNewBest() { [523, 659, 784, 1047, 1319].forEach((f, i) => setTimeout(() => tone(f, 0.15, 'sine', 0.25), i * 100)); }

  // --- Screen Shake ---
  function triggerShake(intensity, duration) {
    shakeIntensity = intensity;
    shakeDuration = duration;
    shakeTimer = duration;
  }

  // --- Screen Flash ---
  function triggerFlash(color, duration) {
    flashColor = color;
    flashAlpha = FLASH_INITIAL_ALPHA;
    flashDuration = duration;
    flashTimer = duration;
  }

  // --- Floating Text ---
  function addFloatingText(x, y, text, color, size, duration) {
    floatingTexts.push({ x, y, text, color, size: size || 22, life: duration || 1.0, maxLife: duration || 1.0, vy: FLOATING_TEXT_SPEED });
  }

  // --- New Best Particles ---
  function spawnNewBestParticles() {
    for (let i = 0; i < NEW_BEST_PARTICLE_COUNT; i++) {
      const a = Math.random() * Math.PI * 2;
      const sp = 60 + Math.random() * 180;
      newBestParticles.push({
        x: W / 2, y: H * 0.35,
        vx: Math.cos(a) * sp, vy: Math.sin(a) * sp - 60,
        life: 1.5 + Math.random(), color: Math.random() < 0.5 ? '#FFD700' : '#FFA500',
        size: 2 + Math.random() * 5
      });
    }
  }

  function init() {
    state = 'title';
    score = 0;
    combo = 0;
    comboTimer = 0;
    misses = 0;
    maxMisses = MAX_MISSES;
    bestScore = parseInt(localStorage.getItem('fruitslice_best') || '0');
    fruits = [];
    halves = [];
    bombs = [];
    particles = [];
    trail = [];
    floatingTexts = [];
    spawnTimer = 1;
    waveCount = 0;
    lastTime = 0;
    paused = false;
    shakeIntensity = 0;
    shakeDuration = 0;
    shakeTimer = 0;
    flashColor = '';
    flashAlpha = 0;
    flashDuration = 0;
    flashTimer = 0;
    newBestTriggered = false;
    newBestParticles = [];
    lastMilestone = 0;
    freezeTimer = 0;
    freezeActive = false;
    swipeSliceCount = 0;
    totalSlices = 0;
    bestCombo = 0;
    transitionAlpha = 0;
    transitionTimer = 0;
    slowMotion = false;
    slowMotionTimer = 0;
    gameOverFade = 0;
    gameOverFading = false;
  }

  function tap() {
    if (state === 'title') { initAudio(); state = 'playing'; transitionAlpha = 1; transitionTimer = TRANSITION_DURATION; return; }
    if (state === 'gameover') { init(); return; }
  }

  function spawnWave() {
    waveCount++;
    const count = Math.min(2 + Math.floor(waveCount / WAVE_COUNT_DIVISOR), MAX_FRUITS_PER_WAVE);
    const hasBomb = waveCount > BOMB_MIN_WAVE && Math.random() < BOMB_CHANCE;
    const hasFreeze = waveCount > FREEZE_MIN_WAVE && Math.random() < FREEZE_CHANCE;

    for (let i = 0; i < count; i++) {
      setTimeout(() => {
        if (state !== 'playing') return;
        const ft = FRUIT_TYPES[Math.floor(Math.random() * FRUIT_TYPES.length)];
        const x = 40 + Math.random() * (W - 80);
        const vx = (W / 2 - x) * (0.3 + Math.random() * 0.5);
        const vy = FRUIT_VY_BASE - Math.random() * FRUIT_VY_RANGE;
        fruits.push({
          x, y: H + 30, vx, vy,
          rotation: Math.random() * Math.PI * 2,
          rotSpeed: (Math.random() - 0.5) * 6,
          type: ft, sliced: false
        });
      }, i * SPAWN_WAVE_DELAY);
    }

    if (hasBomb) {
      setTimeout(() => {
        if (state !== 'playing') return;
        const x = 60 + Math.random() * (W - 120);
        const vx = (W / 2 - x) * 0.4;
        bombs.push({
          x, y: H + 30, vx, vy: BOMB_VY_BASE - Math.random() * BOMB_VY_RANGE,
          rotation: 0, rotSpeed: 3
        });
      }, Math.random() * count * SPAWN_WAVE_DELAY);
    }

    if (hasFreeze) {
      setTimeout(() => {
        if (state !== 'playing') return;
        const x = 50 + Math.random() * (W - 100);
        const vx = (W / 2 - x) * 0.4;
        fruits.push({
          x, y: H + 30, vx, vy: FREEZE_VY_BASE - Math.random() * FREEZE_VY_RANGE,
          rotation: Math.random() * Math.PI * 2,
          rotSpeed: (Math.random() - 0.5) * 4,
          type: FREEZE_TYPE, sliced: false
        });
      }, Math.random() * count * SPAWN_WAVE_DELAY);
    }
  }

  function sliceFruit(fruit) {
    fruit.sliced = true;
    score++;
    combo++;
    comboTimer = COMBO_TIMEOUT;
    swipeSliceCount++;
    totalSlices++;
    if (combo > bestCombo) bestCombo = combo;

    if (fruit.type.isFreeze) {
      sndFreeze();
      freezeTimer = FREEZE_DURATION;
      freezeActive = true;
      addFloatingText(W / 2, H * 0.35, 'FROZEN!', '#A3D8FF', 40, 2.0);
      addFloatingText(W / 2, H * 0.42, '\u2744 \u2744 \u2744', '#DFE6FF', 22, 1.6);
      triggerFlash('rgba(116,185,255,0.4)', 0.6);
      for (let i = 0; i < FREEZE_PARTICLE_COUNT; i++) {
        const a = Math.random() * Math.PI * 2;
        const sp = 60 + Math.random() * 120;
        particles.push({
          x: fruit.x, y: fruit.y,
          vx: Math.cos(a) * sp, vy: Math.sin(a) * sp - 40,
          life: 1.2, color: Math.random() < 0.5 ? '#74B9FF' : '#DFE6FF',
          size: 2 + Math.random() * 4, sparkle: true
        });
      }
    } else {
      sndSlice();
    }

    if (combo > 1) {
      sndCombo();
      addFloatingText(fruit.x, fruit.y - 30, 'COMBO x' + combo + '!', '#FDCB6E', 20, 0.9);
    }

    addFloatingText(fruit.x + 15, fruit.y - 15, '+1', '#fff', 18, 0.7);

    // Milestone every 25 points
    const newMilestone = Math.floor(score / MILESTONE_INTERVAL);
    if (newMilestone > lastMilestone) {
      lastMilestone = newMilestone;
      sndMilestone();
      addFloatingText(W / 2, H * 0.35, score + ' POINTS!', '#FDCB6E', 32, 1.5);
      triggerFlash('rgba(253,203,110,0.25)', 0.5);
      for (let i = 0; i < MILESTONE_PARTICLE_COUNT; i++) {
        const a = Math.random() * Math.PI * 2;
        const sp = 80 + Math.random() * 160;
        particles.push({
          x: W / 2, y: H * 0.4,
          vx: Math.cos(a) * sp, vy: Math.sin(a) * sp - 80,
          life: 1.5, color: ['#FDCB6E', '#E74C3C', '#2ECC71', '#74B9FF', '#E67E22'][Math.floor(Math.random() * 5)],
          size: 3 + Math.random() * 5
        });
      }
    }

    // New best check
    if (score > bestScore && !newBestTriggered && bestScore > 0) {
      newBestTriggered = true;
      sndNewBest();
      addFloatingText(W / 2, H * 0.25, 'NEW BEST!', '#FFD700', 36, 2.5);
      triggerFlash('rgba(255,215,0,0.3)', 0.6);
      spawnNewBestParticles();
    }

    // Create two halves
    const angle = Math.random() * Math.PI;
    for (let side = -1; side <= 1; side += 2) {
      halves.push({
        x: fruit.x, y: fruit.y,
        vx: fruit.vx + Math.cos(angle + Math.PI / 2) * side * 80,
        vy: fruit.vy - 50,
        rotation: fruit.rotation,
        rotSpeed: side * 5,
        type: fruit.type, side,
        life: 1.5
      });
    }

    // Enhanced juice particles
    const color = fruit.type.color;
    const pCount = fruit.type.isFreeze ? 15 : SLICE_PARTICLE_COUNT;
    for (let i = 0; i < pCount; i++) {
      const a = Math.random() * Math.PI * 2;
      const sp = 80 + Math.random() * 200;
      particles.push({
        x: fruit.x, y: fruit.y,
        vx: Math.cos(a) * sp, vy: Math.sin(a) * sp - 50,
        life: 1, color, size: 2 + Math.random() * 5
      });
    }

    // Sparkle trail at slice point
    for (let i = 0; i < 6; i++) {
      particles.push({
        x: fruit.x + (Math.random() - 0.5) * 20,
        y: fruit.y + (Math.random() - 0.5) * 20,
        vx: (Math.random() - 0.5) * 40,
        vy: -30 - Math.random() * 60,
        life: 0.8 + Math.random() * 0.4,
        color: '#fff', size: 1 + Math.random() * 2, sparkle: true
      });
    }
  }

  function checkCriticalSlice() {
    if (swipeSliceCount >= CRITICAL_SLICE_THRESHOLD) {
      const bonus = swipeSliceCount;
      score += bonus;
      sndCritical();
      addFloatingText(W / 2, H * 0.45, 'CRITICAL x' + swipeSliceCount + '! +' + bonus, '#FF6348', 28, 1.5);
      triggerFlash('rgba(255,99,72,0.2)', 0.3);
      for (let i = 0; i < CRITICAL_PARTICLE_COUNT; i++) {
        const a = Math.random() * Math.PI * 2;
        const sp = 100 + Math.random() * 150;
        particles.push({
          x: W / 2, y: H * 0.5,
          vx: Math.cos(a) * sp, vy: Math.sin(a) * sp - 60,
          life: 1.2, color: Math.random() < 0.5 ? '#FF6348' : '#FFD700',
          size: 3 + Math.random() * 5, sparkle: true
        });
      }
    }
  }

  function hitBomb(bx, by) {
    if (slowMotion) return; // prevent double-death during slow-motion
    sndBomb();
    triggerShake(BOMB_SHAKE_INTENSITY, BOMB_SHAKE_DURATION);
    triggerFlash('rgba(231,76,60,0.4)', 0.3);
    slowMotion = true;
    slowMotionTimer = SLOW_MOTION_DURATION;
    bestScore = Math.max(score, bestScore);
    localStorage.setItem('fruitslice_best', bestScore);

    const cx = bx || W / 2, cy = by || H / 2;
    for (let i = 0; i < BOMB_EXPLOSION_COUNT; i++) {
      const a = Math.random() * Math.PI * 2;
      const sp = 100 + Math.random() * 300;
      const colors = ['#E74C3C', '#FF6348', '#FF9F43', '#FFD700', '#636E72'];
      particles.push({
        x: cx, y: cy,
        vx: Math.cos(a) * sp, vy: Math.sin(a) * sp,
        life: 1.5 + Math.random(),
        color: colors[Math.floor(Math.random() * colors.length)],
        size: 3 + Math.random() * 8
      });
    }
    for (let i = 0; i < BOMB_SMOKE_COUNT; i++) {
      const a = Math.random() * Math.PI * 2;
      const sp = 30 + Math.random() * 80;
      particles.push({
        x: cx, y: cy,
        vx: Math.cos(a) * sp, vy: Math.sin(a) * sp - 40,
        life: 2, color: 'rgba(100,100,100,0.6)', size: 8 + Math.random() * 12
      });
    }
  }

  function handleMissDeath() {
    if (slowMotion) return; // prevent double-death during slow-motion
    triggerShake(MISS_SHAKE_INTENSITY, MISS_SHAKE_DURATION);
    triggerFlash('rgba(231,76,60,0.3)', 0.25);
    slowMotion = true;
    slowMotionTimer = SLOW_MOTION_DURATION;
    bestScore = Math.max(score, bestScore);
    localStorage.setItem('fruitslice_best', bestScore);
  }

  function toggleMute() {
    muted = !muted;
    localStorage.setItem('fruitslice_muted', muted ? 'true' : 'false');
  }

  let swiping = false;
  let swipePrev = null;

  function getPos(e) {
    const rect = canvas.getBoundingClientRect();
    return {
      x: (e.clientX - rect.left) * (W / rect.width),
      y: (e.clientY - rect.top) * (H / rect.height)
    };
  }

  function onSwipeStart(e) {
    if (state !== 'playing') { tap(); return; }
    if (paused) return;
    swiping = true;
    swipePrev = getPos(e);
    trail.push({ ...swipePrev, life: 1 });
    swipeSliceCount = 0;
  }

  function onSwipeMove(e) {
    if (!swiping || state !== 'playing' || paused) return;
    const pos = getPos(e);
    trail.push({ ...pos, life: 1 });
    if (trail.length > TRAIL_MAX_LENGTH) trail.shift();

    if (Math.random() < 0.4) {
      particles.push({
        x: pos.x + (Math.random() - 0.5) * 10,
        y: pos.y + (Math.random() - 0.5) * 10,
        vx: (Math.random() - 0.5) * 20,
        vy: (Math.random() - 0.5) * 20 - 15,
        life: 0.5, color: '#fff', size: 1 + Math.random() * 1.5, sparkle: true
      });
    }

    if (swipePrev) {
      for (const f of fruits) {
        if (f.sliced) continue;
        if (circleLineIntersect(f.x, f.y, f.type.r, swipePrev.x, swipePrev.y, pos.x, pos.y)) {
          sliceFruit(f);
        }
      }
      for (const b of bombs) {
        if (circleLineIntersect(b.x, b.y, BOMB_RADIUS, swipePrev.x, swipePrev.y, pos.x, pos.y)) {
          hitBomb(b.x, b.y); return;
        }
      }
    }
    swipePrev = pos;
  }

  function onSwipeEnd() {
    if (swiping) checkCriticalSlice();
    swiping = false;
    swipePrev = null;
    swipeSliceCount = 0;
  }

  function circleLineIntersect(cx, cy, cr, x1, y1, x2, y2) {
    const dx = x2 - x1, dy = y2 - y1;
    const lenSq = dx * dx + dy * dy;
    if (lenSq === 0) return Math.sqrt((cx - x1) ** 2 + (cy - y1) ** 2) < cr;
    let t = ((cx - x1) * dx + (cy - y1) * dy) / lenSq;
    t = Math.max(0, Math.min(1, t));
    const nearX = x1 + t * dx, nearY = y1 + t * dy;
    return Math.sqrt((cx - nearX) ** 2 + (cy - nearY) ** 2) < cr;
  }

  function isMuteClick(e) {
    const pos = getPos(e);
    const dx = pos.x - MUTE_CX, dy = pos.y - MUTE_CY;
    return dx * dx + dy * dy <= (MUTE_R + 4) * (MUTE_R + 4);
  }

  function update(dt) {
    // --- Screen Transition Logic ---
    if (slowMotion) {
      dt *= SLOW_MOTION_FACTOR;
      slowMotionTimer -= dt * (1 / SLOW_MOTION_FACTOR); // decrement in real time
      if (slowMotionTimer <= 0) {
        slowMotion = false;
        state = 'gameover';
        gameOverFade = 0;
        gameOverFading = true;
      }
    }

    if (transitionTimer > 0) {
      transitionTimer -= dt;
      transitionAlpha = Math.max(0, transitionTimer / TRANSITION_DURATION);
    }

    if (gameOverFading) {
      gameOverFade = Math.min(1, gameOverFade + dt * GAME_OVER_FADE_SPEED);
      if (gameOverFade >= 1) gameOverFading = false;
    }

    if (shakeTimer > 0) {
      shakeTimer -= dt;
      if (shakeTimer < 0) shakeTimer = 0;
    }

    if (flashTimer > 0) {
      flashTimer -= dt;
      flashAlpha = 0.5 * (flashTimer / flashDuration);
      if (flashTimer < 0) { flashTimer = 0; flashAlpha = 0; }
    }

    for (let i = floatingTexts.length - 1; i >= 0; i--) {
      const ft = floatingTexts[i];
      ft.y += ft.vy * dt;
      ft.life -= dt;
      if (ft.life <= 0) floatingTexts.splice(i, 1);
    }

    for (let i = newBestParticles.length - 1; i >= 0; i--) {
      const p = newBestParticles[i];
      p.x += p.vx * dt; p.y += p.vy * dt;
      p.vy += NEW_BEST_GRAVITY * dt;
      p.life -= dt;
      if (p.life <= 0) newBestParticles.splice(i, 1);
    }

    if (state !== 'playing') return;
    if (paused) return;

    const timeScale = freezeActive ? FREEZE_TIME_SCALE : 1.0;
    if (freezeActive) {
      freezeTimer -= dt;
      if (freezeTimer <= 0) { freezeActive = false; freezeTimer = 0; }
    }
    const adt = dt * timeScale;

    spawnTimer -= dt;
    if (spawnTimer <= 0) {
      spawnWave();
      spawnTimer = Math.max(SPAWN_INTERVAL_MIN, SPAWN_INTERVAL_BASE - waveCount * SPAWN_INTERVAL_DECAY);
    }

    for (let i = fruits.length - 1; i >= 0; i--) {
      const f = fruits[i];
      f.x += f.vx * adt;
      f.y += f.vy * adt;
      f.vy += GRAVITY * adt;
      f.rotation += f.rotSpeed * adt;

      if (f.y > H + 50) {
        if (!f.sliced && !f.type.isFreeze) {
          sndMiss();
          misses++;
          if (misses >= maxMisses) {
            handleMissDeath();
          }
        }
        fruits.splice(i, 1);
      }
    }

    for (let i = bombs.length - 1; i >= 0; i--) {
      const b = bombs[i];
      b.x += b.vx * adt;
      b.y += b.vy * adt;
      b.vy += GRAVITY * adt;
      b.rotation += b.rotSpeed * adt;
      if (b.y > H + 50) bombs.splice(i, 1);
    }

    for (let i = halves.length - 1; i >= 0; i--) {
      const h = halves[i];
      h.x += h.vx * adt;
      h.y += h.vy * adt;
      h.vy += GRAVITY * adt;
      h.rotation += h.rotSpeed * adt;
      h.life -= dt;
      if (h.life <= 0 || h.y > H + 100) halves.splice(i, 1);
    }

    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      p.x += p.vx * dt; p.y += p.vy * dt;
      p.vy += PARTICLE_GRAVITY * dt;
      p.life -= dt * PARTICLE_DECAY;
      if (p.life <= 0) particles.splice(i, 1);
    }

    for (let i = trail.length - 1; i >= 0; i--) {
      trail[i].life -= dt * TRAIL_DECAY;
      if (trail[i].life <= 0) trail.splice(i, 1);
    }

    if (combo > 0) {
      comboTimer -= dt;
      if (comboTimer <= 0) combo = 0;
    }
  }

  function applyShake() {
    if (shakeTimer > 0) {
      const factor = shakeTimer / shakeDuration;
      const ox = (Math.random() - 0.5) * 2 * shakeIntensity * factor;
      const oy = (Math.random() - 0.5) * 2 * shakeIntensity * factor;
      ctx.translate(ox, oy);
    }
  }

  function renderFlash() {
    if (flashTimer > 0 && flashColor) {
      ctx.save();
      ctx.globalAlpha = flashAlpha;
      ctx.fillStyle = flashColor;
      ctx.fillRect(0, 0, W, H);
      ctx.globalAlpha = 1;
      ctx.restore();
    }
  }

  function renderFloatingTexts() {
    floatingTexts.forEach(ft => {
      const alpha = Math.min(1, ft.life / (ft.maxLife * 0.3));
      ctx.save();
      ctx.globalAlpha = Math.max(0, alpha);
      ctx.fillStyle = ft.color;
      ctx.font = 'bold ' + ft.size + 'px "Avenir Next", "Segoe UI", system-ui, sans-serif';
      ctx.textAlign = 'center';
      ctx.shadowColor = 'rgba(0,0,0,0.5)';
      ctx.shadowBlur = 4;
      ctx.fillText(ft.text, ft.x, ft.y);
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1;
      ctx.restore();
    });
  }

  function renderNewBestParticles() {
    newBestParticles.forEach(p => {
      ctx.globalAlpha = Math.max(0, Math.min(1, p.life));
      ctx.fillStyle = p.color;
      ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill();
    });
    ctx.globalAlpha = 1;
  }

  // Mute button constants
  const MUTE_CX = W - 28, MUTE_CY = 67, MUTE_R = 20;
  let muteHovered = false;

  function renderMuteButton() {
    ctx.save();
    ctx.beginPath();
    ctx.arc(MUTE_CX, MUTE_CY, MUTE_R, 0, Math.PI * 2);
    ctx.fillStyle = muteHovered ? 'rgba(0,0,0,0.2)' : 'rgba(0,0,0,0.1)';
    ctx.fill();
    ctx.fillStyle = '#2C3E50';
    ctx.fillRect(MUTE_CX - 12, MUTE_CY - 4, 6, 8);
    ctx.beginPath();
    ctx.moveTo(MUTE_CX - 6, MUTE_CY - 4);
    ctx.lineTo(MUTE_CX, MUTE_CY - 9);
    ctx.lineTo(MUTE_CX, MUTE_CY + 9);
    ctx.lineTo(MUTE_CX - 6, MUTE_CY + 4);
    ctx.closePath();
    ctx.fill();
    if (muted) {
      ctx.strokeStyle = '#E74C3C'; ctx.lineWidth = 2.5; ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(MUTE_CX + 3, MUTE_CY - 5); ctx.lineTo(MUTE_CX + 11, MUTE_CY + 5);
      ctx.moveTo(MUTE_CX + 11, MUTE_CY - 5); ctx.lineTo(MUTE_CX + 3, MUTE_CY + 5);
      ctx.stroke();
    } else {
      ctx.strokeStyle = 'rgba(44,62,80,0.7)'; ctx.lineWidth = 1.8; ctx.lineCap = 'round';
      ctx.beginPath(); ctx.arc(MUTE_CX + 2, MUTE_CY, 5, -Math.PI * 0.35, Math.PI * 0.35); ctx.stroke();
      ctx.beginPath(); ctx.arc(MUTE_CX + 2, MUTE_CY, 10, -Math.PI * 0.35, Math.PI * 0.35); ctx.stroke();
    }
    if (muteHovered) {
      const label = muted ? 'Unmute (M)' : 'Mute (M)';
      ctx.font = '12px "Avenir Next", "Segoe UI", system-ui, sans-serif';
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      const tw = ctx.measureText(label).width + 14;
      const ty = MUTE_CY + MUTE_R + 14;
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.beginPath(); ctx.roundRect(MUTE_CX - tw / 2, ty - 11, tw, 22, 6); ctx.fill();
      ctx.fillStyle = '#fff'; ctx.fillText(label, MUTE_CX, ty);
    }
    ctx.restore();
  }

  function renderFreezeOverlay() {
    if (freezeActive) {
      ctx.save();
      const freezeAlpha = Math.min(0.12, freezeTimer * 0.05);
      ctx.fillStyle = 'rgba(116,185,255,' + freezeAlpha + ')';
      ctx.fillRect(0, 0, W, H);
      ctx.strokeStyle = 'rgba(116,185,255,' + (freezeAlpha * 2) + ')';
      ctx.lineWidth = 6;
      ctx.strokeRect(3, 3, W - 6, H - 6);
      ctx.restore();
    }
  }

  function render() {
    ctx.save();
    applyShake();

    const grad = ctx.createLinearGradient(0, 0, 0, H);
    grad.addColorStop(0, '#FFEAA7');
    grad.addColorStop(1, '#DFE6E9');
    ctx.fillStyle = grad;
    ctx.fillRect(-20, -20, W + 40, H + 40);

    ctx.fillStyle = 'rgba(0,0,0,0.02)';
    for (let y = 0; y < H; y += 30) {
      ctx.fillRect(0, y, W, 1);
    }

    if (trail.length > 1) {
      for (let i = 1; i < trail.length; i++) {
        const t = trail[i];
        const prev = trail[i - 1];
        ctx.strokeStyle = 'rgba(255,255,255,' + (t.life * 0.8) + ')';
        ctx.lineWidth = 3 + t.life * 4;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(prev.x, prev.y);
        ctx.lineTo(t.x, t.y);
        ctx.stroke();
      }
    }

    fruits.forEach(f => {
      if (f.sliced) return;
      ctx.save();
      ctx.translate(f.x, f.y);
      ctx.rotate(f.rotation);

      ctx.fillStyle = 'rgba(0,0,0,0.1)';
      ctx.beginPath(); ctx.arc(3, 3, f.type.r, 0, Math.PI * 2); ctx.fill();

      ctx.fillStyle = f.type.color;
      ctx.beginPath(); ctx.arc(0, 0, f.type.r, 0, Math.PI * 2); ctx.fill();

      ctx.fillStyle = 'rgba(255,255,255,0.25)';
      ctx.beginPath(); ctx.arc(-f.type.r * 0.25, -f.type.r * 0.3, f.type.r * 0.4, 0, Math.PI * 2); ctx.fill();

      if (f.type.isFreeze) {
        const sparkAlpha = 0.3 + 0.3 * Math.sin(Date.now() / 150);
        ctx.fillStyle = 'rgba(255,255,255,' + sparkAlpha + ')';
        ctx.beginPath(); ctx.arc(f.type.r * 0.3, -f.type.r * 0.1, f.type.r * 0.2, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(-f.type.r * 0.1, f.type.r * 0.3, f.type.r * 0.15, 0, Math.PI * 2); ctx.fill();
        ctx.strokeStyle = 'rgba(255,255,255,' + (0.4 + sparkAlpha * 0.3) + ')';
        ctx.lineWidth = 1.5;
        for (let a = 0; a < 3; a++) {
          const ang = a * Math.PI / 3;
          ctx.beginPath();
          ctx.moveTo(Math.cos(ang) * -6, Math.sin(ang) * -6);
          ctx.lineTo(Math.cos(ang) * 6, Math.sin(ang) * 6);
          ctx.stroke();
        }
      }

      if (f.type.leaf) {
        ctx.fillStyle = '#00B894';
        ctx.beginPath();
        ctx.ellipse(4, -f.type.r + 2, 7, 4, 0.3, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#00B894';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, -f.type.r + 4);
        ctx.quadraticCurveTo(2, -f.type.r - 4, 6, -f.type.r - 2);
        ctx.stroke();
      }

      ctx.restore();
    });

    bombs.forEach(b => {
      ctx.save();
      ctx.translate(b.x, b.y);
      ctx.rotate(b.rotation);

      ctx.fillStyle = '#636E72';
      ctx.beginPath(); ctx.arc(0, 0, 22, 0, Math.PI * 2); ctx.fill();

      ctx.fillStyle = 'rgba(255,255,255,0.15)';
      ctx.beginPath(); ctx.arc(-6, -6, 8, 0, Math.PI * 2); ctx.fill();

      ctx.strokeStyle = '#B2BEC3';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(0, -22);
      ctx.quadraticCurveTo(6, -30, 10, -28);
      ctx.stroke();

      const sparkAlpha = 0.5 + 0.5 * Math.sin(Date.now() / 100);
      ctx.fillStyle = 'rgba(255, 165, 0, ' + sparkAlpha + ')';
      ctx.beginPath(); ctx.arc(10, -28, 4, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = 'rgba(255, 255, 0, ' + (sparkAlpha * 0.7) + ')';
      ctx.beginPath(); ctx.arc(10, -28, 2, 0, Math.PI * 2); ctx.fill();

      const spAngle = Date.now() / 80;
      ctx.fillStyle = 'rgba(255,200,0,' + (sparkAlpha * 0.5) + ')';
      ctx.beginPath();
      ctx.arc(10 + Math.cos(spAngle) * 3, -28 + Math.sin(spAngle) * 3, 1.5, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = 'rgba(255,100,0,' + (sparkAlpha * 0.4) + ')';
      ctx.beginPath();
      ctx.arc(10 + Math.cos(spAngle + 2) * 4, -28 + Math.sin(spAngle + 2) * 4, 1, 0, Math.PI * 2);
      ctx.fill();

      ctx.strokeStyle = '#E74C3C';
      ctx.lineWidth = 3;
      ctx.beginPath(); ctx.moveTo(-8, -8); ctx.lineTo(8, 8); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(8, -8); ctx.lineTo(-8, 8); ctx.stroke();

      ctx.restore();
    });

    halves.forEach(h => {
      ctx.save();
      ctx.translate(h.x, h.y);
      ctx.rotate(h.rotation);
      ctx.globalAlpha = Math.min(1, h.life);

      ctx.beginPath();
      ctx.arc(0, 0, h.type.r, h.side > 0 ? 0 : Math.PI, h.side > 0 ? Math.PI : Math.PI * 2);
      ctx.closePath();
      ctx.fillStyle = h.type.color;
      ctx.fill();

      ctx.beginPath();
      ctx.arc(0, 0, h.type.r * 0.85, h.side > 0 ? 0 : Math.PI, h.side > 0 ? Math.PI : Math.PI * 2);
      ctx.closePath();
      ctx.fillStyle = h.type.inner;
      ctx.fill();

      ctx.globalAlpha = 1;
      ctx.restore();
    });

    particles.forEach(p => {
      ctx.globalAlpha = Math.max(0, p.life);
      ctx.fillStyle = p.color;
      if (p.sparkle) {
        const flicker = 0.5 + 0.5 * Math.sin(Date.now() / 60 + p.x);
        ctx.globalAlpha = Math.max(0, p.life) * flicker;
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(Date.now() / 200 + p.y);
        ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size);
        ctx.restore();
      } else {
        ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill();
      }
    });
    ctx.globalAlpha = 1;

    renderFreezeOverlay();
    renderFlash();
    renderNewBestParticles();
    renderFloatingTexts();

    ctx.save();
    ctx.fillStyle = 'rgba(44, 62, 80, 0.8)';
    ctx.font = 'bold 32px "Avenir Next", "Segoe UI", system-ui, sans-serif';
    ctx.textAlign = 'left';
    ctx.shadowColor = 'rgba(253, 203, 110, 0.6)';
    ctx.shadowBlur = 12;
    ctx.fillText(score, 20, 42);
    ctx.shadowBlur = 0;
    ctx.restore();

    if (bestScore > 0 && !newBestTriggered) {
      ctx.fillStyle = 'rgba(44,62,80,0.35)';
      ctx.font = '13px "Avenir Next", "Segoe UI", system-ui, sans-serif';
      ctx.fillText('Best: ' + bestScore, 22, 62);
    }

    if (combo > 1) {
      ctx.fillStyle = '#E74C3C';
      ctx.font = 'bold 24px "Avenir Next", "Segoe UI", system-ui, sans-serif';
      ctx.textAlign = 'center';
      const comboScale = 1 + (combo > 3 ? 0.2 : 0);
      ctx.save();
      ctx.translate(W / 2, 100);
      ctx.scale(comboScale, comboScale);
      ctx.fillText(combo + 'x Combo!', 0, 0);
      ctx.restore();
    }

    for (let i = 0; i < maxMisses; i++) {
      ctx.fillStyle = i < (maxMisses - misses) ? '#E74C3C' : 'rgba(231,76,60,0.25)';
      ctx.font = '20px "Avenir Next", "Segoe UI", system-ui, sans-serif';
      ctx.textAlign = 'right';
      ctx.fillText('\u2764', W - 15 - i * 25, 38);
    }

    renderMuteButton();

    if (freezeActive) {
      ctx.fillStyle = '#74B9FF';
      ctx.font = 'bold 14px "Avenir Next", "Segoe UI", system-ui, sans-serif';
      ctx.textAlign = 'left';
      const barW = 60;
      const frac = freezeTimer / FREEZE_DURATION;
      ctx.fillRect(20, H - 30, barW * frac, 8);
      ctx.strokeStyle = 'rgba(116,185,255,0.5)';
      ctx.lineWidth = 1;
      ctx.strokeRect(20, H - 30, barW, 8);
      ctx.fillText('FROZEN', 20, H - 36);
    }

    if (paused) {
      ctx.fillStyle = 'rgba(0,0,0,0.55)';
      ctx.fillRect(0, 0, W, H);
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 44px "Avenir Next", "Segoe UI", system-ui, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('PAUSED', W / 2, H * 0.4);
      ctx.font = '20px "Avenir Next", "Segoe UI", system-ui, sans-serif';
      ctx.fillStyle = 'rgba(255,255,255,0.6)';
      ctx.fillText('Press P to resume', W / 2, H * 0.48);
      ctx.fillText('M to toggle sound', W / 2, H * 0.54);
    }

    // --- Fade-in overlay ---
    if (transitionAlpha > 0) {
      ctx.fillStyle = 'rgba(0,0,0,' + transitionAlpha + ')';
      ctx.fillRect(-20, -20, W + 40, H + 40);
    }

    ctx.restore();
  }

  function renderTitle() {
    const grad = ctx.createLinearGradient(0, 0, 0, H);
    grad.addColorStop(0, '#FFEAA7');
    grad.addColorStop(1, '#DFE6E9');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, W, H);

    const time = Date.now() / 1000;
    const demoFruits = [
      { x: 100, y: 350 + Math.sin(time) * 20, type: FRUIT_TYPES[0], rot: time },
      { x: 200, y: 300 + Math.sin(time + 1) * 25, type: FRUIT_TYPES[2], rot: -time * 0.8 },
      { x: 300, y: 360 + Math.sin(time + 2) * 15, type: FRUIT_TYPES[3], rot: time * 1.2 },
    ];
    demoFruits.forEach(f => {
      ctx.save();
      ctx.translate(f.x, f.y);
      ctx.rotate(f.rot);
      ctx.fillStyle = f.type.color;
      ctx.beginPath(); ctx.arc(0, 0, f.type.r, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = 'rgba(255,255,255,0.25)';
      ctx.beginPath(); ctx.arc(-5, -5, f.type.r * 0.35, 0, Math.PI * 2); ctx.fill();
      ctx.restore();
    });

    ctx.save();
    ctx.strokeStyle = 'rgba(255,255,255,0.5)';
    ctx.lineWidth = 3;
    ctx.shadowColor = 'rgba(255,255,255,0.8)';
    ctx.shadowBlur = 10;
    ctx.beginPath(); ctx.moveTo(60, 400); ctx.lineTo(340, 280); ctx.stroke();
    ctx.shadowBlur = 0;
    ctx.restore();

    ctx.fillStyle = '#2D3436';
    ctx.font = 'bold 48px "Avenir Next", "Segoe UI", system-ui, sans-serif';
    ctx.textAlign = 'center';
    ctx.shadowColor = 'rgba(0,0,0,0.1)';
    ctx.shadowBlur = 8;
    ctx.fillText('FRUIT', W / 2, H * 0.16);
    ctx.fillText('SLICE', W / 2, H * 0.24);
    ctx.shadowBlur = 0;

    const alpha = 0.5 + 0.5 * Math.sin(Date.now() / 500);
    ctx.globalAlpha = alpha;
    ctx.fillStyle = '#636E72';
    ctx.font = '22px "Avenir Next", "Segoe UI", system-ui, sans-serif';
    ctx.fillText('Tap to Play', W / 2, H * 0.68);
    ctx.globalAlpha = 1;

    ctx.font = '16px "Avenir Next", "Segoe UI", system-ui, sans-serif';
    ctx.fillStyle = 'rgba(100,100,100,0.7)';
    ctx.fillText('Swipe to slice \u2014 avoid the bombs!', W / 2, H * 0.75);
    ctx.fillText('P = Pause | M = Mute', W / 2, H * 0.79);

    if (bestScore > 0) {
      ctx.fillStyle = '#E74C3C';
      ctx.font = '18px "Avenir Next", "Segoe UI", system-ui, sans-serif';
      ctx.fillText('Best: ' + bestScore, W / 2, H * 0.86);
    }

    renderMuteButton();
  }

  function renderGameOver() {
    ctx.save();
    applyShake();
    render();

    const fade = gameOverFading || gameOverFade < 1 ? gameOverFade : 1;
    ctx.fillStyle = 'rgba(0,0,0,' + (0.55 * fade) + ')';
    ctx.fillRect(-20, -20, W + 40, H + 40);

    ctx.globalAlpha = fade;

    ctx.fillStyle = '#fff';
    ctx.font = 'bold 44px "Avenir Next", "Segoe UI", system-ui, sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Game Over', W / 2, H * 0.28);
    ctx.font = 'bold 64px "Avenir Next", "Segoe UI", system-ui, sans-serif';
    ctx.fillText(score, W / 2, H * 0.42);
    ctx.font = '20px "Avenir Next", "Segoe UI", system-ui, sans-serif';
    ctx.fillStyle = '#FDCB6E';
    ctx.fillText('Best: ' + bestScore, W / 2, H * 0.50);

    ctx.font = '15px "Avenir Next", "Segoe UI", system-ui, sans-serif';
    ctx.fillStyle = 'rgba(255,255,255,0.55)';
    ctx.fillText('Slices: ' + totalSlices + '    Best Combo: ' + bestCombo + 'x', W / 2, H * 0.555);

    if (newBestTriggered) {
      const pulse = 1 + 0.1 * Math.sin(Date.now() / 200);
      ctx.save();
      ctx.translate(W / 2, H * 0.60);
      ctx.scale(pulse, pulse);
      ctx.fillStyle = '#FFD700';
      ctx.font = 'bold 22px "Avenir Next", "Segoe UI", system-ui, sans-serif';
      ctx.fillText('NEW BEST!', 0, 0);
      ctx.restore();
    }

    ctx.fillStyle = '#E74C3C';
    roundRect(W / 2 - 90, H * 0.66, 180, 50, 25);
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 20px "Avenir Next", "Segoe UI", system-ui, sans-serif';
    ctx.fillText('Play Again', W / 2, H * 0.66 + 32);

    ctx.globalAlpha = 1;

    renderNewBestParticles();
    renderFloatingTexts();

    ctx.restore();
  }

  function roundRect(x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    ctx.fill();
  }

  function gameLoop(ts) {
    const dt = Math.min((ts - lastTime) / 1000, 0.05);
    lastTime = ts;
    update(dt);
    if (state === 'title') renderTitle();
    else if (state === 'playing') render();
    else renderGameOver();
    requestAnimationFrame(gameLoop);
  }

  canvas.addEventListener('mousedown', e => {
    if (isMuteClick(e)) { toggleMute(); return; }
    onSwipeStart(e);
  });
  canvas.addEventListener('mousemove', e => {
    const pos = getPos(e);
    const dx = pos.x - MUTE_CX, dy = pos.y - MUTE_CY;
    muteHovered = dx * dx + dy * dy <= (MUTE_R + 4) * (MUTE_R + 4);
    canvas.style.cursor = muteHovered ? 'pointer' : 'default';
    onSwipeMove(e);
  });
  canvas.addEventListener('mouseup', () => { onSwipeEnd(); });
  canvas.addEventListener('mouseleave', () => { muteHovered = false; onSwipeEnd(); });

  canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    const t = e.touches[0];
    const fakeEvt = { clientX: t.clientX, clientY: t.clientY };
    if (isMuteClick(fakeEvt)) { toggleMute(); return; }
    onSwipeStart(fakeEvt);
  }, { passive: false });

  canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    const t = e.touches[0];
    onSwipeMove({ clientX: t.clientX, clientY: t.clientY });
  }, { passive: false });

  canvas.addEventListener('touchend', e => { e.preventDefault(); onSwipeEnd(); }, { passive: false });

  window.addEventListener('keydown', e => {
    if (e.key === 'p' || e.key === 'P') {
      if (state === 'playing') paused = !paused;
    }
    if (e.key === 'm' || e.key === 'M') {
      toggleMute();
    }
  });

  init();
  requestAnimationFrame(gameLoop);
})();
</script>
</body>
</html>