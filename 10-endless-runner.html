<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Endless Runner</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  html, body { height: 100%; overflow: hidden; background: #2D3436; touch-action: manipulation; }
  body { display: flex; align-items: center; justify-content: center; }
  canvas { display: block; }
  .home-link { position: fixed; top: 12px; left: 12px; color: rgba(255,255,255,0.6); text-decoration: none; font-family: sans-serif; font-size: 0.85rem; z-index: 10; }
  .home-link:hover { color: #fff; }
</style>
</head>
<body>
<a class="home-link" href="index.html">&#8592; Games</a>
<canvas id="c"></canvas>
<script>
(() => {
  const W = 400, H = 700;
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  canvas.width = W; canvas.height = H;

  function resize() {
    const a = W / H;
    let w = window.innerWidth, h = window.innerHeight;
    if (w / h > a) w = h * a; else h = w / a;
    canvas.style.width = w + 'px'; canvas.style.height = h + 'px';
  }
  window.addEventListener('resize', resize); resize();

  const GROUND_Y = H - 120;
  const GRAVITY = 1800;
  const JUMP_VEL = -680;
  const PLAYER_W = 30, PLAYER_H = 50;
  const PLAYER_X = 70;

  let state, score, bestScore, player, obstacles, coins, shields, lastTime;
  let scrollSpeed, distance, spawnTimer, particles;
  let parallaxLayers, groundOffset;
  let jumpHeld, jumpTime;
  let paused, muted;
  let screenShake, screenFlash, floatingTexts;
  let lastMilestone, scoreMultiplier, nearMissTimer;
  let dustTimer;
  let newBestTriggered;

  muted = localStorage.getItem('runner_muted') === 'true';

  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  let actx;
  function initAudio() { if (!actx) actx = new AudioCtx(); if (actx.state === 'suspended') actx.resume(); }
  function tone(freq, dur, type, vol) { if (!actx || muted) return; const o = actx.createOscillator(), g = actx.createGain(); o.type = type || 'sine'; o.frequency.setValueAtTime(freq, actx.currentTime); g.gain.setValueAtTime(vol || 0.3, actx.currentTime); g.gain.exponentialRampToValueAtTime(0.001, actx.currentTime + dur); o.connect(g); g.connect(actx.destination); o.start(); o.stop(actx.currentTime + dur); }
  function sweep(f1, f2, dur, type, vol) { if (!actx || muted) return; const o = actx.createOscillator(), g = actx.createGain(); o.type = type || 'sine'; o.frequency.setValueAtTime(f1, actx.currentTime); o.frequency.exponentialRampToValueAtTime(f2, actx.currentTime + dur); g.gain.setValueAtTime(vol || 0.3, actx.currentTime); g.gain.exponentialRampToValueAtTime(0.001, actx.currentTime + dur); o.connect(g); g.connect(actx.destination); o.start(); o.stop(actx.currentTime + dur); }
  function noise(dur, vol) { if (!actx || muted) return; const buf = actx.createBuffer(1, actx.sampleRate * dur | 0, actx.sampleRate); const d = buf.getChannelData(0); for (let i = 0; i < d.length; i++) d[i] = Math.random() * 2 - 1; const s = actx.createBufferSource(), g = actx.createGain(); s.buffer = buf; g.gain.setValueAtTime(vol || 0.15, actx.currentTime); g.gain.exponentialRampToValueAtTime(0.001, actx.currentTime + dur); s.connect(g); g.connect(actx.destination); s.start(); }
  function sndJump() { sweep(250, 500, 0.12, 'sine', 0.25); }
  function sndDuck() { tone(180, 0.08, 'square', 0.15); }
  function sndCoin() { tone(880, 0.08, 'sine', 0.25); setTimeout(() => tone(1100, 0.1, 'sine', 0.25), 70); }
  function sndHit() { noise(0.2, 0.3); sweep(350, 80, 0.4, 'sawtooth', 0.2); }
  function sndShield() { tone(600, 0.1, 'sine', 0.2); setTimeout(() => tone(800, 0.1, 'sine', 0.2), 60); setTimeout(() => tone(1000, 0.15, 'sine', 0.2), 120); }
  function sndShieldBreak() { noise(0.15, 0.2); sweep(500, 200, 0.3, 'square', 0.15); }
  function sndMilestone() { tone(523, 0.1, 'sine', 0.2); setTimeout(() => tone(659, 0.1, 'sine', 0.2), 80); setTimeout(() => tone(784, 0.15, 'sine', 0.25), 160); }
  function sndNewBest() { tone(523, 0.1, 'sine', 0.25); setTimeout(() => tone(659, 0.1, 'sine', 0.25), 100); setTimeout(() => tone(784, 0.1, 'sine', 0.25), 200); setTimeout(() => tone(1047, 0.2, 'sine', 0.3), 300); }
  function sndNearMiss() { tone(1200, 0.06, 'sine', 0.15); }

  function init() {
    state = 'title';
    score = 0;
    bestScore = parseInt(localStorage.getItem('runner_best') || '0');
    distance = 0;
    scrollSpeed = 240;
    spawnTimer = 0;
    particles = [];
    lastTime = 0;
    jumpHeld = false;
    jumpTime = 0;
    groundOffset = 0;
    paused = false;
    screenShake = { intensity: 0, duration: 0, timer: 0 };
    screenFlash = { color: '', alpha: 0, duration: 0, timer: 0 };
    floatingTexts = [];
    lastMilestone = 0;
    scoreMultiplier = 1;
    nearMissTimer = 0;
    dustTimer = 0;
    newBestTriggered = false;

    player = {
      x: PLAYER_X, y: GROUND_Y - PLAYER_H,
      vy: 0, grounded: true, ducking: false, duckTimer: 0,
      jumpsLeft: 1, runFrame: 0, runTimer: 0,
      hasDoubleJump: false, hasShield: false
    };

    obstacles = [];
    coins = [];
    shields = [];

    parallaxLayers = [
      { y: GROUND_Y - 200, h: 200, speed: 0.1, color: '#B2BEC3', shapes: genMountains(5, 200) },
      { y: GROUND_Y - 140, h: 140, speed: 0.3, color: '#636E72', shapes: genMountains(8, 140) },
    ];
  }

  function genMountains(count, maxH) {
    const shapes = [];
    for (let i = 0; i < count; i++) {
      shapes.push({ x: i * (W / count) + Math.random() * 40, w: 60 + Math.random() * 80, h: 30 + Math.random() * (maxH * 0.6) });
    }
    return shapes;
  }

  function triggerShake(intensity, duration) {
    screenShake.intensity = intensity;
    screenShake.duration = duration;
    screenShake.timer = duration;
  }

  function triggerFlash(color, duration) {
    screenFlash.color = color;
    screenFlash.alpha = 0.5;
    screenFlash.duration = duration;
    screenFlash.timer = duration;
  }

  function addFloatingText(text, x, y, color, size) {
    floatingTexts.push({
      text, x, y, color: color || '#fff',
      size: size || 24, vy: -80, life: 1.5, maxLife: 1.5
    });
  }

  function getSkyColors() {
    const cycle = (distance % 10000) / 10000;
    let topColor, bottomColor;
    if (cycle < 0.3) {
      const t = cycle / 0.3;
      topColor = lerpColor('#74B9FF', '#FF7675', t * t);
      bottomColor = lerpColor('#A29BFE', '#FDCB6E', t * t);
    } else if (cycle < 0.5) {
      const t = (cycle - 0.3) / 0.2;
      topColor = lerpColor('#FF7675', '#2D3436', t);
      bottomColor = lerpColor('#FDCB6E', '#636E72', t);
    } else if (cycle < 0.8) {
      topColor = '#2D3436';
      bottomColor = '#636E72';
    } else {
      const t = (cycle - 0.8) / 0.2;
      topColor = lerpColor('#2D3436', '#74B9FF', t);
      bottomColor = lerpColor('#636E72', '#A29BFE', t);
    }
    return { top: topColor, bottom: bottomColor };
  }

  function lerpColor(c1, c2, t) {
    t = Math.max(0, Math.min(1, t));
    const r1 = parseInt(c1.slice(1, 3), 16), g1 = parseInt(c1.slice(3, 5), 16), b1 = parseInt(c1.slice(5, 7), 16);
    const r2 = parseInt(c2.slice(1, 3), 16), g2 = parseInt(c2.slice(3, 5), 16), b2 = parseInt(c2.slice(5, 7), 16);
    const r = Math.round(r1 + (r2 - r1) * t);
    const g = Math.round(g1 + (g2 - g1) * t);
    const b = Math.round(b1 + (b2 - b1) * t);
    return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
  }

  function jump() {
    if (state === 'title') { initAudio(); state = 'playing'; return; }
    if (state === 'gameover') { init(); return; }
    if (paused) return;
    if (player.grounded) {
      sndJump();
      player.vy = JUMP_VEL;
      player.grounded = false;
      player.jumpsLeft = player.hasDoubleJump ? 1 : 0;
      jumpHeld = true;
      jumpTime = 0;
      addJumpParticles();
    } else if (player.jumpsLeft > 0) {
      sndJump();
      player.vy = JUMP_VEL * 0.85;
      player.jumpsLeft--;
      jumpHeld = true;
      jumpTime = 0;
      addJumpParticles();
      addFloatingText('DOUBLE JUMP!', player.x + PLAYER_W / 2, player.y - 20, '#FDCB6E', 18);
      triggerShake(3, 0.15);
    }
  }

  function duck(start) {
    if (state !== 'playing' || paused) return;
    player.ducking = start;
    if (start) { sndDuck(); player.duckTimer = 0.5; }
  }

  function togglePause() {
    if (state !== 'playing') return;
    paused = !paused;
  }

  function toggleMute() {
    muted = !muted;
    localStorage.setItem('runner_muted', muted.toString());
  }

  function addJumpParticles() {
    for (let i = 0; i < 6; i++) {
      particles.push({
        x: player.x + PLAYER_W / 2, y: GROUND_Y,
        vx: -50 - Math.random() * 80, vy: -20 - Math.random() * 60,
        life: 1, color: '#DFE6E9', size: 2 + Math.random() * 3
      });
    }
  }

  function addLandingParticles() {
    for (let i = 0; i < 10; i++) {
      const angle = Math.PI + Math.random() * Math.PI;
      const speed = 40 + Math.random() * 100;
      particles.push({
        x: player.x + PLAYER_W / 2, y: GROUND_Y,
        vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed * 0.5 - 30,
        life: 0.8, color: '#B2BEC3', size: 2 + Math.random() * 3
      });
    }
  }

  function addDustParticle() {
    particles.push({
      x: player.x + PLAYER_W / 2 - 5 + Math.random() * 10,
      y: GROUND_Y - 2,
      vx: -20 - Math.random() * 30,
      vy: -5 - Math.random() * 15,
      life: 0.5 + Math.random() * 0.3,
      color: '#B2BEC3',
      size: 1.5 + Math.random() * 2
    });
  }

  function addCoinSparkles(x, y) {
    for (let i = 0; i < 12; i++) {
      const a = Math.random() * Math.PI * 2;
      const speed = 60 + Math.random() * 120;
      particles.push({
        x, y,
        vx: Math.cos(a) * speed, vy: Math.sin(a) * speed,
        life: 1, color: i % 2 === 0 ? '#FDCB6E' : '#F39C12',
        size: 2 + Math.random() * 3, sparkle: true
      });
    }
  }

  function addShieldParticles(x, y) {
    for (let i = 0; i < 15; i++) {
      const a = Math.random() * Math.PI * 2;
      const speed = 80 + Math.random() * 100;
      particles.push({
        x, y,
        vx: Math.cos(a) * speed, vy: Math.sin(a) * speed,
        life: 0.8, color: i % 3 === 0 ? '#74B9FF' : '#0984E3',
        size: 2 + Math.random() * 4
      });
    }
  }

  function addNewBestParticles() {
    for (let i = 0; i < 30; i++) {
      const a = Math.random() * Math.PI * 2;
      const speed = 50 + Math.random() * 150;
      particles.push({
        x: W / 2 + (Math.random() - 0.5) * 100,
        y: H * 0.3 + (Math.random() - 0.5) * 50,
        vx: Math.cos(a) * speed, vy: Math.sin(a) * speed,
        life: 1.5 + Math.random() * 0.5,
        color: ['#FDCB6E', '#F39C12', '#E17055', '#FFD700'][Math.floor(Math.random() * 4)],
        size: 2 + Math.random() * 4, sparkle: true
      });
    }
  }

  function checkNearMiss(obstacle) {
    const px = player.x + 4, pw = PLAYER_W - 8;
    const py = player.ducking ? player.y + PLAYER_H * 0.5 : player.y + 4;
    const ph = player.ducking ? PLAYER_H * 0.5 : PLAYER_H - 8;
    const horizOverlap = px + pw > obstacle.x - 5 && px < obstacle.x + obstacle.w + 5;
    if (!horizOverlap) return false;
    if (obstacle.type === 'overhead') {
      const gap = obstacle.y + obstacle.h - py;
      return gap > -15 && gap < 10;
    } else {
      const gap = py + ph - obstacle.y;
      return gap > -15 && gap < 5;
    }
  }

  function update(dt) {
    if (state !== 'playing' || paused) return;

    distance += scrollSpeed * dt;
    score = Math.floor(distance / 20) * scoreMultiplier;
    scrollSpeed = Math.min(500, 240 + distance * 0.005);
    groundOffset = (groundOffset + scrollSpeed * dt) % 40;

    if (scoreMultiplier > 1) {
      scoreMultiplier = Math.max(1, scoreMultiplier - dt * 0.1);
    }

    if (nearMissTimer > 0) nearMissTimer -= dt;

    if (jumpHeld && !player.grounded) {
      jumpTime += dt;
      if (jumpTime > 0.2) jumpHeld = false;
      else player.vy = Math.min(player.vy, JUMP_VEL * 0.8);
    }

    const prevGrounded = player.grounded;

    player.vy += GRAVITY * dt;
    player.y += player.vy * dt;

    if (player.y >= GROUND_Y - PLAYER_H) {
      player.y = GROUND_Y - PLAYER_H;
      if (!prevGrounded && player.vy > 200) {
        addLandingParticles();
        const impactStrength = Math.min(player.vy / 800, 1);
        triggerShake(impactStrength * 4, 0.1);
      }
      player.vy = 0;
      player.grounded = true;
      player.jumpsLeft = player.hasDoubleJump ? 1 : 0;
    }

    if (player.ducking) {
      player.duckTimer -= dt;
      if (player.duckTimer <= 0) player.ducking = false;
    }

    if (player.grounded && !player.ducking) {
      player.runTimer += dt;
      if (player.runTimer > 0.12) {
        player.runTimer = 0;
        player.runFrame = 1 - player.runFrame;
      }
    }

    if (player.grounded && !player.ducking) {
      dustTimer += dt;
      const dustInterval = Math.max(0.03, 0.1 - scrollSpeed * 0.0001);
      if (dustTimer >= dustInterval) {
        dustTimer = 0;
        addDustParticle();
      }
    }

    const currentMilestone = Math.floor(score / 500) * 500;
    if (currentMilestone > lastMilestone && currentMilestone > 0) {
      lastMilestone = currentMilestone;
      sndMilestone();
      triggerFlash('#FDCB6E', 0.3);
      addFloatingText('+' + currentMilestone, W / 2, H * 0.35, '#FDCB6E', 30);
      scoreMultiplier = Math.min(3, scoreMultiplier + 0.5);
      addFloatingText(scoreMultiplier.toFixed(1) + 'x', W / 2, H * 0.42, '#FF7675', 20);
    }

    if (!newBestTriggered && score > bestScore && bestScore > 0) {
      newBestTriggered = true;
      sndNewBest();
      addFloatingText('NEW BEST!', W / 2, H * 0.25, '#FFD700', 36);
      addNewBestParticles();
      triggerFlash('#FFD700', 0.4);
    }

    spawnTimer -= dt;
    if (spawnTimer <= 0) {
      spawnObstacle();
      spawnTimer = Math.max(0.7, 1.8 - distance * 0.0003) + Math.random() * 0.5;
    }

    for (let i = obstacles.length - 1; i >= 0; i--) {
      const o = obstacles[i];
      o.x -= scrollSpeed * dt;
      if (o.x + o.w < -20) { obstacles.splice(i, 1); continue; }

      if (!o.nearMissChecked && o.x < player.x + PLAYER_W + 5 && o.x + o.w > player.x - 5) {
        if (checkNearMiss(o) && nearMissTimer <= 0) {
          o.nearMissChecked = true;
          nearMissTimer = 0.5;
          score += 50;
          sndNearMiss();
          addFloatingText('NEAR MISS +50', player.x + PLAYER_W, player.y - 10, '#FF7675', 16);
        }
      }
      if (o.x + o.w < player.x) o.nearMissChecked = true;

      const px = player.x + 4, pw = PLAYER_W - 8;
      const py = player.ducking ? player.y + PLAYER_H * 0.5 : player.y + 4;
      const ph = player.ducking ? PLAYER_H * 0.5 : PLAYER_H - 8;

      if (px + pw > o.x && px < o.x + o.w && py + ph > o.y && py < o.y + o.h) {
        if (player.hasShield) {
          player.hasShield = false;
          sndShieldBreak();
          addShieldParticles(player.x + PLAYER_W / 2, player.y + PLAYER_H / 2);
          triggerShake(5, 0.2);
          addFloatingText('SHIELD!', player.x + PLAYER_W / 2, player.y - 20, '#74B9FF', 20);
          obstacles.splice(i, 1);
          continue;
        }
        die();
        return;
      }
    }

    for (let i = coins.length - 1; i >= 0; i--) {
      const c = coins[i];
      c.x -= scrollSpeed * dt;
      if (c.x < -20) { coins.splice(i, 1); continue; }

      const dx = (player.x + PLAYER_W / 2) - c.x;
      const dy = (player.y + PLAYER_H / 2) - c.y;
      if (Math.sqrt(dx * dx + dy * dy) < 25) {
        sndCoin();
        player.hasDoubleJump = true;
        addCoinSparkles(c.x, c.y);
        addFloatingText('DOUBLE JUMP!', c.x, c.y - 15, '#FDCB6E', 16);
        coins.splice(i, 1);
      }
    }

    for (let i = shields.length - 1; i >= 0; i--) {
      const s = shields[i];
      s.x -= scrollSpeed * dt;
      if (s.x < -20) { shields.splice(i, 1); continue; }

      const dx = (player.x + PLAYER_W / 2) - s.x;
      const dy = (player.y + PLAYER_H / 2) - s.y;
      if (Math.sqrt(dx * dx + dy * dy) < 25) {
        sndShield();
        player.hasShield = true;
        addShieldParticles(s.x, s.y);
        addFloatingText('SHIELD!', s.x, s.y - 15, '#74B9FF', 16);
        shields.splice(i, 1);
      }
    }

    parallaxLayers.forEach(l => { l.offset = (l.offset || 0) + scrollSpeed * l.speed * dt; });

    if (screenShake.timer > 0) {
      screenShake.timer -= dt;
      if (screenShake.timer <= 0) screenShake.timer = 0;
    }

    if (screenFlash.timer > 0) {
      screenFlash.timer -= dt;
      screenFlash.alpha = 0.5 * (screenFlash.timer / screenFlash.duration);
      if (screenFlash.timer <= 0) { screenFlash.timer = 0; screenFlash.alpha = 0; }
    }

    for (let i = floatingTexts.length - 1; i >= 0; i--) {
      const ft = floatingTexts[i];
      ft.y += ft.vy * dt;
      ft.life -= dt;
      if (ft.life <= 0) floatingTexts.splice(i, 1);
    }

    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      p.x += p.vx * dt; p.y += p.vy * dt;
      p.vy += 300 * dt;
      p.life -= dt * 3;
      if (p.life <= 0) particles.splice(i, 1);
    }
  }

  function spawnObstacle() {
    const r = Math.random();
    if (r < 0.5) {
      const h = 30 + Math.random() * 30;
      obstacles.push({ x: W + 10, y: GROUND_Y - h, w: 25 + Math.random() * 20, h, type: 'ground', nearMissChecked: false });
    } else if (r < 0.8) {
      obstacles.push({ x: W + 10, y: GROUND_Y - 60 - Math.random() * 20, w: 20, h: 60 + Math.random() * 20, type: 'ground', nearMissChecked: false });
    } else {
      obstacles.push({ x: W + 10, y: GROUND_Y - PLAYER_H - 20 - Math.random() * 30, w: 60 + Math.random() * 40, h: 20, type: 'overhead', nearMissChecked: false });
    }

    if (Math.random() < 0.2) {
      coins.push({ x: W + 200, y: GROUND_Y - 80 - Math.random() * 100 });
    }

    if (Math.random() < 0.06 && !player.hasShield) {
      shields.push({ x: W + 300, y: GROUND_Y - 60 - Math.random() * 120 });
    }
  }

  function die() {
    sndHit();
    state = 'gameover';
    const prevBest = bestScore;
    bestScore = Math.max(score, bestScore);
    localStorage.setItem('runner_best', bestScore);
    triggerShake(10, 0.4);
    triggerFlash('rgba(255,0,0,0.8)', 0.4);

    for (let i = 0; i < 15; i++) {
      const a = Math.random() * Math.PI * 2;
      const speed = 80 + Math.random() * 150;
      particles.push({
        x: player.x + PLAYER_W / 2, y: player.y + PLAYER_H / 2,
        vx: Math.cos(a) * speed, vy: Math.sin(a) * speed,
        life: 1.2, color: '#6C5CE7', size: 3 + Math.random() * 4
      });
    }

    if (score > prevBest && prevBest > 0) {
      if (!newBestTriggered) {
        addNewBestParticles();
        sndNewBest();
      }
      newBestTriggered = true;
    }
  }

  function renderMuteIcon() {
    const ix = W - 36, iy = 88, sz = 20;
    ctx.save();
    ctx.globalAlpha = 0.6;
    ctx.fillStyle = '#fff'; ctx.strokeStyle = '#fff'; ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(ix, iy + 6); ctx.lineTo(ix + 5, iy + 6);
    ctx.lineTo(ix + 10, iy + 1); ctx.lineTo(ix + 10, iy + sz - 1);
    ctx.lineTo(ix + 5, iy + sz - 6); ctx.lineTo(ix, iy + sz - 6);
    ctx.closePath(); ctx.fill();
    if (muted) {
      ctx.strokeStyle = '#ff6666'; ctx.lineWidth = 2.5;
      ctx.beginPath();
      ctx.moveTo(ix + 13, iy + 5); ctx.lineTo(ix + 20, iy + sz - 5);
      ctx.moveTo(ix + 20, iy + 5); ctx.lineTo(ix + 13, iy + sz - 5);
      ctx.stroke();
    } else {
      ctx.strokeStyle = '#fff'; ctx.lineWidth = 1.5;
      ctx.beginPath(); ctx.arc(ix + 12, iy + sz / 2, 4, -Math.PI * 0.4, Math.PI * 0.4); ctx.stroke();
      ctx.beginPath(); ctx.arc(ix + 12, iy + sz / 2, 8, -Math.PI * 0.4, Math.PI * 0.4); ctx.stroke();
    }
    ctx.restore();
  }

  function render() {
    ctx.save();

    if (screenShake.timer > 0) {
      const shakeProgress = screenShake.timer / screenShake.duration;
      const intensity = screenShake.intensity * shakeProgress;
      const sx = (Math.random() - 0.5) * intensity * 2;
      const sy = (Math.random() - 0.5) * intensity * 2;
      ctx.translate(sx, sy);
    }

    const skyColors = getSkyColors();
    const sky = ctx.createLinearGradient(0, 0, 0, GROUND_Y);
    sky.addColorStop(0, skyColors.top);
    sky.addColorStop(1, skyColors.bottom);
    ctx.fillStyle = sky;
    ctx.fillRect(-10, -10, W + 20, GROUND_Y + 20);

    const cycle = (distance % 10000) / 10000;
    if (cycle > 0.4 && cycle < 0.9) {
      const nightAlpha = cycle < 0.5 ? (cycle - 0.4) / 0.1 : cycle > 0.8 ? (0.9 - cycle) / 0.1 : 1;
      ctx.fillStyle = '#fff';
      for (let i = 0; i < 30; i++) {
        const starX = ((i * 137 + 53) % W);
        const starY = ((i * 97 + 29) % (GROUND_Y - 100)) + 20;
        const twinkle = 0.5 + 0.5 * Math.sin(Date.now() / (300 + i * 50) + i);
        ctx.globalAlpha = nightAlpha * twinkle * 0.8;
        ctx.beginPath();
        ctx.arc(starX, starY, 1 + (i % 3 === 0 ? 1 : 0), 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;
    }

    parallaxLayers.forEach(l => {
      ctx.fillStyle = l.color;
      l.shapes.forEach(s => {
        const sx = ((s.x - (l.offset || 0)) % (W + 200) + W + 200) % (W + 200) - 100;
        ctx.beginPath();
        ctx.moveTo(sx - s.w / 2, l.y + l.h);
        ctx.lineTo(sx, l.y + l.h - s.h);
        ctx.lineTo(sx + s.w / 2, l.y + l.h);
        ctx.closePath();
        ctx.fill();
      });
    });

    ctx.fillStyle = '#00B894';
    ctx.fillRect(-10, GROUND_Y, W + 20, 4);
    ctx.fillStyle = '#E17055';
    ctx.fillRect(-10, GROUND_Y + 4, W + 20, H - GROUND_Y - 4 + 10);

    ctx.fillStyle = '#C0392B';
    for (let x = -groundOffset; x < W + 40; x += 40) {
      ctx.fillRect(x, GROUND_Y + 4, 20, 6);
    }

    obstacles.forEach(o => {
      if (o.type === 'overhead') {
        ctx.fillStyle = '#FD79A8';
        roundRect(o.x, o.y, o.w, o.h, 4);
        ctx.strokeStyle = '#FD79A8';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(o.x + 5, o.y); ctx.lineTo(o.x + 5, 0);
        ctx.moveTo(o.x + o.w - 5, o.y); ctx.lineTo(o.x + o.w - 5, 0);
        ctx.stroke();
      } else {
        ctx.fillStyle = '#E74C3C';
        roundRect(o.x, o.y, o.w, o.h, 4);
        ctx.fillStyle = 'rgba(255,255,255,0.15)';
        ctx.fillRect(o.x + 3, o.y + 3, o.w - 6, 4);
      }
    });

    coins.forEach(c => {
      const pulse = 1 + 0.1 * Math.sin(Date.now() / 200);
      ctx.fillStyle = '#FDCB6E';
      ctx.shadowColor = '#FDCB6E';
      ctx.shadowBlur = 8;
      ctx.beginPath(); ctx.arc(c.x, c.y, 10 * pulse, 0, Math.PI * 2); ctx.fill();
      ctx.shadowBlur = 0;
      ctx.fillStyle = '#F39C12';
      ctx.font = 'bold 12px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('+', c.x, c.y + 4);
    });

    shields.forEach(s => {
      const pulse = 1 + 0.12 * Math.sin(Date.now() / 250);
      ctx.fillStyle = '#74B9FF';
      ctx.shadowColor = '#0984E3';
      ctx.shadowBlur = 12;
      ctx.beginPath(); ctx.arc(s.x, s.y, 11 * pulse, 0, Math.PI * 2); ctx.fill();
      ctx.shadowBlur = 0;
      ctx.fillStyle = '#0984E3';
      ctx.font = 'bold 14px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('\u2666', s.x, s.y + 5);
    });

    const px = player.x, py = player.y;
    ctx.save();

    if (player.hasShield) {
      const shieldAlpha = 0.4 + 0.3 * Math.sin(Date.now() / 300);
      ctx.strokeStyle = 'rgba(116, 185, 255, ' + shieldAlpha + ')';
      ctx.lineWidth = 3;
      ctx.shadowColor = '#0984E3';
      ctx.shadowBlur = 10;
      ctx.beginPath();
      if (player.ducking) {
        ctx.ellipse(px + PLAYER_W / 2 + 5, py + PLAYER_H - 10, PLAYER_W, 16, 0, 0, Math.PI * 2);
      } else {
        ctx.ellipse(px + PLAYER_W / 2, py + PLAYER_H / 2, PLAYER_W * 0.7, PLAYER_H * 0.6, 0, 0, Math.PI * 2);
      }
      ctx.stroke();
      ctx.shadowBlur = 0;
    }

    if (player.ducking) {
      ctx.fillStyle = '#6C5CE7';
      roundRect(px, py + PLAYER_H - 20, PLAYER_W + 10, 20, 6);
      ctx.fillStyle = '#6C5CE7';
      ctx.beginPath(); ctx.arc(px + PLAYER_W + 5, py + PLAYER_H - 10, 8, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#fff';
      ctx.beginPath(); ctx.arc(px + PLAYER_W + 8, py + PLAYER_H - 12, 3, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#2D3436';
      ctx.beginPath(); ctx.arc(px + PLAYER_W + 9, py + PLAYER_H - 12, 1.5, 0, Math.PI * 2); ctx.fill();
    } else {
      ctx.fillStyle = '#6C5CE7';
      roundRect(px + 3, py + 15, PLAYER_W - 6, PLAYER_H - 25, 6);

      ctx.beginPath(); ctx.arc(px + PLAYER_W / 2, py + 10, 10, 0, Math.PI * 2); ctx.fill();

      ctx.fillStyle = '#fff';
      ctx.beginPath(); ctx.arc(px + PLAYER_W / 2 + 4, py + 8, 3.5, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#2D3436';
      ctx.beginPath(); ctx.arc(px + PLAYER_W / 2 + 5, py + 8, 1.8, 0, Math.PI * 2); ctx.fill();

      ctx.strokeStyle = '#6C5CE7';
      ctx.lineWidth = 4;
      ctx.lineCap = 'round';
      if (player.grounded) {
        const legAnim = player.runFrame === 0 ? 1 : -1;
        ctx.beginPath();
        ctx.moveTo(px + 10, py + PLAYER_H - 10);
        ctx.lineTo(px + 10 + legAnim * 8, py + PLAYER_H);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(px + 20, py + PLAYER_H - 10);
        ctx.lineTo(px + 20 - legAnim * 8, py + PLAYER_H);
        ctx.stroke();
      } else {
        ctx.beginPath();
        ctx.moveTo(px + 12, py + PLAYER_H - 10);
        ctx.lineTo(px + 10, py + PLAYER_H);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(px + 18, py + PLAYER_H - 10);
        ctx.lineTo(px + 20, py + PLAYER_H);
        ctx.stroke();
      }
    }

    if (player.hasDoubleJump) {
      ctx.fillStyle = 'rgba(253, 203, 110, 0.6)';
      ctx.beginPath(); ctx.arc(px + PLAYER_W / 2, py - 5, 4, 0, Math.PI * 2); ctx.fill();
    }

    ctx.restore();

    particles.forEach(p => {
      ctx.globalAlpha = Math.max(0, p.life);
      ctx.fillStyle = p.color;
      if (p.sparkle) {
        const sz = p.size * (0.5 + 0.5 * Math.sin(Date.now() / 100 + p.x));
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(Date.now() / 200 + p.x);
        ctx.fillRect(-sz / 2, -sz / 2, sz, sz);
        ctx.restore();
      } else {
        ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill();
      }
    });
    ctx.globalAlpha = 1;

    if (scrollSpeed > 300) {
      const lineIntensity = Math.min(1, (scrollSpeed - 300) / 200);
      const lineCount = Math.floor(3 + lineIntensity * 12);
      ctx.strokeStyle = 'rgba(255,255,255,' + (0.08 + lineIntensity * 0.15) + ')';
      ctx.lineWidth = 1;
      for (let i = 0; i < lineCount; i++) {
        const ly = 60 + Math.random() * (GROUND_Y - 100);
        const lx = Math.random() * W;
        const lineLen = 20 + lineIntensity * 40;
        ctx.beginPath(); ctx.moveTo(lx, ly); ctx.lineTo(lx - lineLen, ly); ctx.stroke();
      }
    }

    floatingTexts.forEach(ft => {
      const ftAlpha = Math.max(0, ft.life / ft.maxLife);
      ctx.globalAlpha = ftAlpha;
      ctx.fillStyle = ft.color;
      ctx.font = 'bold ' + ft.size + 'px Arial, sans-serif';
      ctx.textAlign = 'center';
      ctx.shadowColor = 'rgba(0,0,0,0.5)';
      ctx.shadowBlur = 4;
      ctx.fillText(ft.text, ft.x, ft.y);
      ctx.shadowBlur = 0;
    });
    ctx.globalAlpha = 1;

    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    ctx.font = 'bold 28px Arial, sans-serif';
    ctx.textAlign = 'right';
    ctx.fillText(Math.floor(score), W - 20, 40);

    if (scoreMultiplier > 1) {
      ctx.fillStyle = '#FF7675';
      ctx.font = 'bold 16px Arial, sans-serif';
      ctx.fillText(scoreMultiplier.toFixed(1) + 'x', W - 20, 60);
    }

    if (player.hasShield) {
      ctx.fillStyle = '#74B9FF';
      ctx.font = '14px Arial, sans-serif';
      ctx.textAlign = 'right';
      ctx.fillText('\u2666 SHIELD', W - 20, scoreMultiplier > 1 ? 78 : 60);
    }

    if (screenFlash.alpha > 0) {
      ctx.fillStyle = screenFlash.color;
      ctx.globalAlpha = screenFlash.alpha;
      ctx.fillRect(-10, -10, W + 20, H + 20);
      ctx.globalAlpha = 1;
    }

    renderMuteIcon();

    ctx.restore();
  }

  function renderTitle() {
    render();
    ctx.fillStyle = 'rgba(0,0,0,0.35)';
    ctx.fillRect(0, 0, W, H);

    ctx.fillStyle = '#fff';
    ctx.font = 'bold 40px Arial, sans-serif';
    ctx.textAlign = 'center';
    ctx.shadowColor = 'rgba(0,0,0,0.3)';
    ctx.shadowBlur = 10;
    ctx.fillText('ENDLESS', W / 2, H * 0.28);
    ctx.fillText('RUNNER', W / 2, H * 0.36);
    ctx.shadowBlur = 0;

    const alpha = 0.5 + 0.5 * Math.sin(Date.now() / 500);
    ctx.globalAlpha = alpha;
    ctx.font = '22px Arial, sans-serif';
    ctx.fillText('Tap to Play', W / 2, H * 0.50);
    ctx.globalAlpha = 1;

    ctx.font = '14px Arial, sans-serif';
    ctx.fillStyle = 'rgba(255,255,255,0.5)';
    ctx.fillText('Tap/Space = Jump, Down = Duck', W / 2, H * 0.57);
    ctx.fillText('P = Pause, M = Mute', W / 2, H * 0.61);

    if (bestScore > 0) {
      ctx.fillStyle = '#FDCB6E';
      ctx.font = '18px Arial, sans-serif';
      ctx.fillText('Best: ' + bestScore, W / 2, H * 0.68);
    }

    renderMuteIcon();
  }

  function renderPause() {
    render();
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.fillRect(0, 0, W, H);

    ctx.fillStyle = '#fff';
    ctx.font = 'bold 44px Arial, sans-serif';
    ctx.textAlign = 'center';
    ctx.shadowColor = 'rgba(0,0,0,0.3)';
    ctx.shadowBlur = 10;
    ctx.fillText('PAUSED', W / 2, H * 0.38);
    ctx.shadowBlur = 0;

    const alpha = 0.5 + 0.5 * Math.sin(Date.now() / 500);
    ctx.globalAlpha = alpha;
    ctx.font = '22px Arial, sans-serif';
    ctx.fillText('Press P to Resume', W / 2, H * 0.48);
    ctx.globalAlpha = 1;

    ctx.font = '16px Arial, sans-serif';
    ctx.fillStyle = 'rgba(255,255,255,0.5)';
    ctx.fillText('Score: ' + Math.floor(score), W / 2, H * 0.55);

    renderMuteIcon();
  }

  function renderGameOver() {
    render();
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(0, 0, W, H);

    ctx.fillStyle = '#fff';
    ctx.font = 'bold 44px Arial, sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Game Over', W / 2, H * 0.28);
    ctx.font = 'bold 64px Arial, sans-serif';
    ctx.fillText(Math.floor(score), W / 2, H * 0.42);
    ctx.font = '20px Arial, sans-serif';
    ctx.fillStyle = '#FDCB6E';
    ctx.fillText('Best: ' + bestScore, W / 2, H * 0.50);

    if (newBestTriggered) {
      const pulseAlpha = 0.7 + 0.3 * Math.sin(Date.now() / 300);
      ctx.globalAlpha = pulseAlpha;
      ctx.fillStyle = '#FFD700';
      ctx.font = 'bold 28px Arial, sans-serif';
      ctx.shadowColor = '#FFD700';
      ctx.shadowBlur = 15;
      ctx.fillText('NEW BEST!', W / 2, H * 0.22);
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1;
    }

    ctx.fillStyle = '#6C5CE7';
    roundRect(W / 2 - 90, H * 0.57, 180, 50, 25);
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 20px Arial, sans-serif';
    ctx.fillText('Play Again', W / 2, H * 0.57 + 32);

    floatingTexts.forEach(ft => {
      const ftA = Math.max(0, ft.life / ft.maxLife);
      ctx.globalAlpha = ftA;
      ctx.fillStyle = ft.color;
      ctx.font = 'bold ' + ft.size + 'px Arial, sans-serif';
      ctx.textAlign = 'center';
      ctx.shadowColor = 'rgba(0,0,0,0.5)';
      ctx.shadowBlur = 4;
      ctx.fillText(ft.text, ft.x, ft.y);
      ctx.shadowBlur = 0;
    });
    ctx.globalAlpha = 1;

    particles.forEach(p => {
      ctx.globalAlpha = Math.max(0, p.life);
      ctx.fillStyle = p.color;
      if (p.sparkle) {
        const sz = p.size * (0.5 + 0.5 * Math.sin(Date.now() / 100 + p.x));
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(Date.now() / 200 + p.x);
        ctx.fillRect(-sz / 2, -sz / 2, sz, sz);
        ctx.restore();
      } else {
        ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill();
      }
    });
    ctx.globalAlpha = 1;

    renderMuteIcon();
  }

  function roundRect(x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    ctx.fill();
  }

  function gameLoop(ts) {
    const dt = Math.min((ts - lastTime) / 1000, 0.05);
    lastTime = ts;

    if (state === 'gameover' || paused) {
      for (let i = floatingTexts.length - 1; i >= 0; i--) {
        floatingTexts[i].y += floatingTexts[i].vy * dt;
        floatingTexts[i].life -= dt;
        if (floatingTexts[i].life <= 0) floatingTexts.splice(i, 1);
      }
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx * dt; p.y += p.vy * dt;
        p.vy += 300 * dt;
        p.life -= dt * 3;
        if (p.life <= 0) particles.splice(i, 1);
      }
      if (screenShake.timer > 0) screenShake.timer = Math.max(0, screenShake.timer - dt);
      if (screenFlash.timer > 0) {
        screenFlash.timer -= dt;
        screenFlash.alpha = 0.5 * (screenFlash.timer / screenFlash.duration);
        if (screenFlash.timer <= 0) { screenFlash.timer = 0; screenFlash.alpha = 0; }
      }
    }

    update(dt);

    if (state === 'title') renderTitle();
    else if (state === 'playing' && paused) renderPause();
    else if (state === 'playing') render();
    else renderGameOver();

    requestAnimationFrame(gameLoop);
  }

  function isMuteIconClick(clientX, clientY) {
    const rect = canvas.getBoundingClientRect();
    const scaleX = W / rect.width;
    const scaleY = H / rect.height;
    const canvasX = (clientX - rect.left) * scaleX;
    const canvasY = (clientY - rect.top) * scaleY;
    return canvasX >= W - 42 && canvasX <= W - 10 && canvasY >= 84 && canvasY <= 114;
  }

  let touchStartY = null;
  canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    const touch = e.touches[0];
    if (isMuteIconClick(touch.clientX, touch.clientY)) {
      toggleMute();
      return;
    }
    touchStartY = touch.clientY;
    jump();
  }, { passive: false });

  canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    if (touchStartY !== null) {
      const dy = e.touches[0].clientY - touchStartY;
      if (dy > 30) { duck(true); touchStartY = null; }
    }
  }, { passive: false });

  canvas.addEventListener('touchend', e => {
    e.preventDefault();
    jumpHeld = false;
    touchStartY = null;
  }, { passive: false });

  canvas.addEventListener('mousedown', e => {
    if (isMuteIconClick(e.clientX, e.clientY)) {
      toggleMute();
      return;
    }
    jump();
  });
  canvas.addEventListener('mouseup', () => { jumpHeld = false; });

  document.addEventListener('keydown', e => {
    if (e.code === 'Space' || e.code === 'ArrowUp') { e.preventDefault(); jump(); }
    if (e.code === 'ArrowDown' || e.code === 'KeyS') { e.preventDefault(); duck(true); }
    if (e.code === 'KeyP') { e.preventDefault(); togglePause(); }
    if (e.code === 'KeyM') { e.preventDefault(); toggleMute(); }
  });
  document.addEventListener('keyup', e => {
    if (e.code === 'Space' || e.code === 'ArrowUp') jumpHeld = false;
  });

  init();
  requestAnimationFrame(gameLoop);
})();
</script>
</body>
</html>