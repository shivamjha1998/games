<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Endless Runner</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  html, body { height: 100%; overflow: hidden; background: #2D3436; touch-action: manipulation; }
  body { display: flex; align-items: center; justify-content: center; }
  canvas { display: block; }
  .home-link { position: fixed; top: 12px; left: 12px; color: rgba(255,255,255,0.7); text-decoration: none; font-family: system-ui, sans-serif; font-size: 0.8rem; z-index: 10; backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px); background: rgba(0,0,0,0.25); padding: 6px 14px; border-radius: 20px; transition: background 0.2s, color 0.2s; }
  .home-link:hover { color: #fff; background: rgba(0,0,0,0.45); }
</style>
</head>
<body>
<a class="home-link" href="index.html">&#8592; Games</a>
<canvas id="c"></canvas>
<script>
(() => {
  /**
   * Endless Runner — Side-scrolling obstacle course
   * Run, jump, and duck to avoid obstacles. Collect coins for bonus points.
   *
   * Controls: Tap/Space to jump, Swipe down/Arrow Down to duck, P to pause, M to mute
   * Rendering: Canvas 2D, 400x700 internal resolution
   * State machine: title → playing → gameover
   */

  const W = 400, H = 700;
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  canvas.width = W * dpr; canvas.height = H * dpr;
  ctx.scale(dpr, dpr);

  function resize() {
    const a = W / H;
    let w = window.innerWidth, h = window.innerHeight;
    if (w / h > a) w = h * a; else h = w / a;
    canvas.style.width = w + 'px'; canvas.style.height = h + 'px';
  }
  window.addEventListener('resize', resize); resize();

  const GROUND_Y = H - 120;
  const GRAVITY = 1800;
  const JUMP_VEL = -680;
  const PLAYER_W = 30, PLAYER_H = 50;
  const PLAYER_X = 70;

  // === CONFIGURATION ===
  // Speed and distance
  const INITIAL_SCROLL_SPEED = 240;
  const MAX_SCROLL_SPEED = 500;
  const SPEED_RAMP = 0.005;
  const SCORE_DIVISOR = 20;
  const GROUND_TILE_WIDTH = 40;

  // Jump
  const DOUBLE_JUMP_FACTOR = 0.85;
  const JUMP_HOLD_DURATION = 0.2;
  const JUMP_HOLD_DAMPEN = 0.8;
  const LANDING_SPEED_THRESHOLD = 200;
  const LANDING_IMPACT_DIVISOR = 800;
  const LANDING_SHAKE_MULTIPLIER = 4;
  const LANDING_SHAKE_DURATION = 0.1;

  // Duck
  const DUCK_DURATION = 0.5;

  // Run animation
  const RUN_FRAME_INTERVAL = 0.12;

  // Dust particles
  const DUST_INTERVAL_MIN = 0.03;
  const DUST_INTERVAL_BASE = 0.1;
  const DUST_SPEED_FACTOR = 0.0001;

  // Obstacle spawning
  const MIN_OBSTACLE_GAP = 0.8; // seconds between obstacles
  const SPAWN_TIMER_BASE = 1.8;
  const SPAWN_TIMER_RAMP = 0.0003;
  const SPAWN_TIMER_MIN = 0.7;
  const SPAWN_TIMER_RANDOM = 0.5;
  const OVERHEAD_CHANCE = 0.8; // r >= this means overhead
  const TALL_OBSTACLE_CHANCE = 0.5; // r >= 0.5 and < 0.8 means tall

  // Obstacle dimensions
  const SHORT_OBS_H_MIN = 30;
  const SHORT_OBS_H_RANGE = 30;
  const SHORT_OBS_W_MIN = 25;
  const SHORT_OBS_W_RANGE = 20;
  const TALL_OBS_BASE_Y = 60;
  const TALL_OBS_Y_RANGE = 20;
  const TALL_OBS_W = 20;
  const TALL_OBS_H_BASE = 60;
  const TALL_OBS_H_RANGE = 20;
  const OVERHEAD_OBS_OFFSET = 20;
  const OVERHEAD_OBS_Y_RANGE = 30;
  const OVERHEAD_OBS_W_MIN = 60;
  const OVERHEAD_OBS_W_RANGE = 40;
  const OVERHEAD_OBS_H = 20;

  // Coin and shield spawning
  const COIN_SPAWN_CHANCE = 0.2;
  const COIN_SPAWN_OFFSET_X = 200;
  const COIN_Y_BASE = 80;
  const COIN_Y_RANGE = 100;
  const SHIELD_SPAWN_CHANCE = 0.06;
  const SHIELD_SPAWN_OFFSET_X = 300;
  const SHIELD_Y_BASE = 60;
  const SHIELD_Y_RANGE = 120;

  // Coin visuals
  const COIN_RADIUS = 10;
  const COIN_PULSE_SPEED = 200;
  const COIN_PULSE_AMPLITUDE = 0.1;
  const COIN_GLOW_BLUR = 8;
  const COIN_PICKUP_RANGE = 25;

  // Shield visuals
  const SHIELD_RADIUS = 11;
  const SHIELD_PULSE_SPEED = 250;
  const SHIELD_PULSE_AMPLITUDE = 0.12;
  const SHIELD_GLOW_BLUR = 12;
  const SHIELD_PICKUP_RANGE = 25;

  // Near miss detection
  const NEAR_MISS_DETECT_PAD = 10;
  const NEAR_MISS_OVERHEAD_GAP_MIN = -22;
  const NEAR_MISS_OVERHEAD_GAP_MAX = 16;
  const NEAR_MISS_GROUND_GAP_MIN = -22;
  const NEAR_MISS_GROUND_GAP_MAX = 12;
  const NEAR_MISS_COOLDOWN = 0.5;
  const NEAR_MISS_SCORE = 50;

  // Milestones
  const MILESTONE_INTERVAL = 500;
  const MAX_SCORE_MULTIPLIER = 3;
  const MULTIPLIER_INCREMENT = 0.5;
  const MULTIPLIER_DECAY = 0.1;

  // Particles
  const PARTICLE_GRAVITY = 300;
  const PARTICLE_DECAY = 3;
  const JUMP_PARTICLE_COUNT = 6;
  const LANDING_PARTICLE_COUNT = 10;
  const COIN_SPARKLE_COUNT = 12;
  const SHIELD_PARTICLE_COUNT = 15;
  const NEW_BEST_PARTICLE_COUNT = 30;
  const DEATH_PARTICLE_COUNT = 15;
  const DEATH_PARTICLE_SPEED_MIN = 80;
  const DEATH_PARTICLE_SPEED_RANGE = 150;

  // Floating text
  const FLOATING_TEXT_VY = -80;
  const FLOATING_TEXT_LIFE = 1.5;
  const FLOATING_TEXT_SHADOW_BLUR = 4;

  // Speed lines
  const SPEED_LINES_THRESHOLD = 300;
  const SPEED_LINES_RANGE = 200;
  const SPEED_LINES_BASE_COUNT = 3;
  const SPEED_LINES_MAX_EXTRA = 12;
  const SPEED_LINE_BASE_LEN = 20;
  const SPEED_LINE_MAX_EXTRA_LEN = 40;

  // Sky cycle
  const SKY_CYCLE_DISTANCE = 10000;
  const NIGHT_STAR_COUNT = 30;

  // Mountains
  const MOUNTAIN_STRIP_EXTEND = 200;

  // Death
  const DEATH_SHAKE_INTENSITY = 10;
  const DEATH_SHAKE_DURATION = 0.4;

  // Swipe threshold
  const SWIPE_DOWN_THRESHOLD = 30;

  // Transitions
  const TRANSITION_DURATION = 0.3;
  const SLOW_MOTION_FACTOR = 0.25;
  const SLOW_MOTION_DURATION = 0.5;
  const GAME_OVER_FADE_SPEED = 3;

  // Audio
  const AUDIO_FADEOUT = 0.001;

  let state, score, bestScore, player, obstacles, coins, shields, lastTime;
  let scrollSpeed, distance, spawnTimer, particles;
  let parallaxLayers, groundOffset;
  let jumpHeld, jumpTime;
  let paused, muted;
  let screenShake, screenFlash, floatingTexts;
  let lastMilestone, scoreMultiplier, nearMissTimer;
  let dustTimer;
  let newBestTriggered;
  let lastObstacleTime, lastObstacleType;
  let nearMissCount;

  // --- Screen Transition State ---
  let transitionAlpha = 0;
  let transitionTimer = 0;
  let slowMotion = false;
  let slowMotionTimer = 0;
  let gameOverFade = 0;
  let gameOverFading = false;

  muted = localStorage.getItem('runner_muted') === 'true';

  // === AUDIO ENGINE ===
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  let actx;

  function initAudio() {
    if (!actx) actx = new AudioCtx();
    if (actx.state === 'suspended') actx.resume();
  }

  function tone(freq, dur, type, vol) {
    if (!actx || muted) return;
    const o = actx.createOscillator();
    const g = actx.createGain();
    o.type = type || 'sine';
    o.frequency.setValueAtTime(freq, actx.currentTime);
    g.gain.setValueAtTime(vol || 0.3, actx.currentTime);
    g.gain.exponentialRampToValueAtTime(AUDIO_FADEOUT, actx.currentTime + dur);
    o.connect(g);
    g.connect(actx.destination);
    o.start();
    o.stop(actx.currentTime + dur);
  }

  function sweep(f1, f2, dur, type, vol) {
    if (!actx || muted) return;
    const o = actx.createOscillator();
    const g = actx.createGain();
    o.type = type || 'sine';
    o.frequency.setValueAtTime(f1, actx.currentTime);
    o.frequency.exponentialRampToValueAtTime(f2, actx.currentTime + dur);
    g.gain.setValueAtTime(vol || 0.3, actx.currentTime);
    g.gain.exponentialRampToValueAtTime(AUDIO_FADEOUT, actx.currentTime + dur);
    o.connect(g);
    g.connect(actx.destination);
    o.start();
    o.stop(actx.currentTime + dur);
  }

  function noise(dur, vol) {
    if (!actx || muted) return;
    const buf = actx.createBuffer(1, actx.sampleRate * dur | 0, actx.sampleRate);
    const data = buf.getChannelData(0);
    for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
    const src = actx.createBufferSource();
    const g = actx.createGain();
    src.buffer = buf;
    g.gain.setValueAtTime(vol || 0.15, actx.currentTime);
    g.gain.exponentialRampToValueAtTime(AUDIO_FADEOUT, actx.currentTime + dur);
    src.connect(g);
    g.connect(actx.destination);
    src.start();
  }

  // === SOUND EFFECTS ===
  // Jump — upward sweep for player jump
  function sndJump() { sweep(250, 500, 0.12, 'sine', 0.25); }
  // Duck — low square tone for ducking action
  function sndDuck() { tone(180, 0.08, 'square', 0.15); }
  // Coin — two-tone chime for coin collection
  function sndCoin() { tone(880, 0.08, 'sine', 0.25); setTimeout(() => tone(1100, 0.1, 'sine', 0.25), 70); }
  // Hit — noise burst + descending sawtooth for collision
  function sndHit() { noise(0.2, 0.3); sweep(350, 80, 0.4, 'sawtooth', 0.2); }
  // Shield — three-tone ascending chime for shield pickup
  function sndShield() { tone(600, 0.1, 'sine', 0.2); setTimeout(() => tone(800, 0.1, 'sine', 0.2), 60); setTimeout(() => tone(1000, 0.15, 'sine', 0.2), 120); }
  // Shield Break — noise + descending square sweep for shield breaking
  function sndShieldBreak() { noise(0.15, 0.2); sweep(500, 200, 0.3, 'square', 0.15); }
  // Milestone — three-note ascending fanfare for distance milestones
  function sndMilestone() { tone(523, 0.1, 'sine', 0.2); setTimeout(() => tone(659, 0.1, 'sine', 0.2), 80); setTimeout(() => tone(784, 0.15, 'sine', 0.25), 160); }
  // New Best — four-note ascending fanfare for new high score
  function sndNewBest() { tone(523, 0.1, 'sine', 0.25); setTimeout(() => tone(659, 0.1, 'sine', 0.25), 100); setTimeout(() => tone(784, 0.1, 'sine', 0.25), 200); setTimeout(() => tone(1047, 0.2, 'sine', 0.3), 300); }
  // Near Miss — short high ping for narrowly avoiding obstacles
  function sndNearMiss() { tone(1200, 0.06, 'sine', 0.15); }

  function init() {
    state = 'title';
    score = 0;
    bestScore = parseInt(localStorage.getItem('runner_best') || '0');
    distance = 0;
    scrollSpeed = INITIAL_SCROLL_SPEED;
    spawnTimer = 0;
    particles = [];
    lastTime = 0;
    jumpHeld = false;
    jumpTime = 0;
    groundOffset = 0;
    paused = false;
    screenShake = { intensity: 0, duration: 0, timer: 0 };
    screenFlash = { color: '', alpha: 0, duration: 0, timer: 0 };
    floatingTexts = [];
    lastMilestone = 0;
    scoreMultiplier = 1;
    nearMissTimer = 0;
    dustTimer = 0;
    newBestTriggered = false;
    lastObstacleTime = 0;
    lastObstacleType = null;
    nearMissCount = 0;
    transitionAlpha = 0;
    transitionTimer = 0;
    slowMotion = false;
    slowMotionTimer = 0;
    gameOverFade = 0;
    gameOverFading = false;

    player = {
      x: PLAYER_X, y: GROUND_Y - PLAYER_H,
      vy: 0, grounded: true, ducking: false, duckTimer: 0,
      jumpsLeft: 1, runFrame: 0, runTimer: 0,
      hasDoubleJump: false, hasShield: false
    };

    obstacles = [];
    coins = [];
    shields = [];

    parallaxLayers = [
      { y: GROUND_Y - 200, h: 200, speed: 0.1, color: '#B2BEC3', shapes: genMountains(5, 200) },
      { y: GROUND_Y - 140, h: 140, speed: 0.3, color: '#636E72', shapes: genMountains(8, 140) },
    ];
  }

  function genMountains(count, maxH) {
    // Generate tileable mountain strip using layered sine waves
    const shapes = [];
    const stripW = W + MOUNTAIN_STRIP_EXTEND;
    for (let i = 0; i < count; i++) {
      const t = i / count;
      const x = t * stripW;
      // Layer multiple sine waves for natural-looking peaks that tile seamlessly
      const h1 = Math.sin(t * Math.PI * 2) * maxH * 0.3;
      const h2 = Math.sin(t * Math.PI * 4 + 1.2) * maxH * 0.2;
      const h3 = Math.sin(t * Math.PI * 6 + 0.7) * maxH * 0.1;
      const h = maxH * 0.25 + Math.abs(h1 + h2 + h3);
      shapes.push({ x: x, w: stripW / count + 20, h: h });
    }
    return shapes;
  }

  function triggerShake(intensity, duration) {
    screenShake.intensity = intensity;
    screenShake.duration = duration;
    screenShake.timer = duration;
  }

  function triggerFlash(color, duration) {
    screenFlash.color = color;
    screenFlash.alpha = 0.5;
    screenFlash.duration = duration;
    screenFlash.timer = duration;
  }

  function addFloatingText(text, x, y, color, size) {
    floatingTexts.push({
      text, x, y, color: color || '#fff',
      size: size || 24, vy: FLOATING_TEXT_VY, life: FLOATING_TEXT_LIFE, maxLife: FLOATING_TEXT_LIFE
    });
  }

  function getSkyColors() {
    const cycle = (distance % SKY_CYCLE_DISTANCE) / SKY_CYCLE_DISTANCE;
    let topColor, bottomColor;
    if (cycle < 0.3) {
      const t = cycle / 0.3;
      topColor = lerpColor('#74B9FF', '#FF7675', t * t);
      bottomColor = lerpColor('#A29BFE', '#FDCB6E', t * t);
    } else if (cycle < 0.5) {
      const t = (cycle - 0.3) / 0.2;
      topColor = lerpColor('#FF7675', '#2D3436', t);
      bottomColor = lerpColor('#FDCB6E', '#636E72', t);
    } else if (cycle < 0.8) {
      topColor = '#2D3436';
      bottomColor = '#636E72';
    } else {
      const t = (cycle - 0.8) / 0.2;
      topColor = lerpColor('#2D3436', '#74B9FF', t);
      bottomColor = lerpColor('#636E72', '#A29BFE', t);
    }
    return { top: topColor, bottom: bottomColor };
  }

  function lerpColor(c1, c2, t) {
    t = Math.max(0, Math.min(1, t));
    const r1 = parseInt(c1.slice(1, 3), 16), g1 = parseInt(c1.slice(3, 5), 16), b1 = parseInt(c1.slice(5, 7), 16);
    const r2 = parseInt(c2.slice(1, 3), 16), g2 = parseInt(c2.slice(3, 5), 16), b2 = parseInt(c2.slice(5, 7), 16);
    const r = Math.round(r1 + (r2 - r1) * t);
    const g = Math.round(g1 + (g2 - g1) * t);
    const b = Math.round(b1 + (b2 - b1) * t);
    return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
  }

  function jump() {
    if (state === 'title') { initAudio(); state = 'playing'; transitionAlpha = 1; transitionTimer = TRANSITION_DURATION; return; }
    if (state === 'gameover') { init(); return; }
    if (paused) return;
    if (player.grounded) {
      sndJump();
      player.vy = JUMP_VEL;
      player.grounded = false;
      player.jumpsLeft = player.hasDoubleJump ? 1 : 0;
      jumpHeld = true;
      jumpTime = 0;
      addJumpParticles();
    } else if (player.jumpsLeft > 0) {
      sndJump();
      player.vy = JUMP_VEL * DOUBLE_JUMP_FACTOR;
      player.jumpsLeft--;
      jumpHeld = true;
      jumpTime = 0;
      addJumpParticles();
      addFloatingText('DOUBLE JUMP!', player.x + PLAYER_W / 2, player.y - 20, '#FDCB6E', 18);
      triggerShake(3, 0.15); // double jump shake
    }
  }

  function duck(start) {
    if (state !== 'playing' || paused) return;
    player.ducking = start;
    if (start) { sndDuck(); player.duckTimer = DUCK_DURATION; }
  }

  function togglePause() {
    if (state !== 'playing') return;
    paused = !paused;
  }

  function toggleMute() {
    muted = !muted;
    localStorage.setItem('runner_muted', muted.toString());
  }

  function addJumpParticles() {
    for (let i = 0; i < JUMP_PARTICLE_COUNT; i++) {
      particles.push({
        x: player.x + PLAYER_W / 2, y: GROUND_Y,
        vx: -50 - Math.random() * 80, vy: -20 - Math.random() * 60,
        life: 1, color: '#DFE6E9', size: 2 + Math.random() * 3
      });
    }
  }

  function addLandingParticles() {
    for (let i = 0; i < LANDING_PARTICLE_COUNT; i++) {
      const angle = Math.PI + Math.random() * Math.PI;
      const speed = 40 + Math.random() * 100;
      particles.push({
        x: player.x + PLAYER_W / 2, y: GROUND_Y,
        vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed * 0.5 - 30,
        life: 0.8, color: '#B2BEC3', size: 2 + Math.random() * 3
      });
    }
  }

  function addDustParticle() {
    particles.push({
      x: player.x + PLAYER_W / 2 - 5 + Math.random() * 10,
      y: GROUND_Y - 2,
      vx: -20 - Math.random() * 30,
      vy: -5 - Math.random() * 15,
      life: 0.5 + Math.random() * 0.3,
      color: '#B2BEC3',
      size: 1.5 + Math.random() * 2
    });
  }

  function addCoinSparkles(x, y) {
    for (let i = 0; i < COIN_SPARKLE_COUNT; i++) {
      const a = Math.random() * Math.PI * 2;
      const speed = 60 + Math.random() * 120;
      particles.push({
        x, y,
        vx: Math.cos(a) * speed, vy: Math.sin(a) * speed,
        life: 1, color: i % 2 === 0 ? '#FDCB6E' : '#F39C12',
        size: 2 + Math.random() * 3, sparkle: true
      });
    }
  }

  function addShieldParticles(x, y) {
    for (let i = 0; i < SHIELD_PARTICLE_COUNT; i++) {
      const a = Math.random() * Math.PI * 2;
      const speed = 80 + Math.random() * 100;
      particles.push({
        x, y,
        vx: Math.cos(a) * speed, vy: Math.sin(a) * speed,
        life: 0.8, color: i % 3 === 0 ? '#74B9FF' : '#0984E3',
        size: 2 + Math.random() * 4
      });
    }
  }

  function addNewBestParticles() {
    for (let i = 0; i < NEW_BEST_PARTICLE_COUNT; i++) {
      const a = Math.random() * Math.PI * 2;
      const speed = 50 + Math.random() * 150;
      particles.push({
        x: W / 2 + (Math.random() - 0.5) * 100,
        y: H * 0.3 + (Math.random() - 0.5) * 50,
        vx: Math.cos(a) * speed, vy: Math.sin(a) * speed,
        life: 1.5 + Math.random() * 0.5,
        color: ['#FDCB6E', '#F39C12', '#E17055', '#FFD700'][Math.floor(Math.random() * 4)],
        size: 2 + Math.random() * 4, sparkle: true
      });
    }
  }

  function checkNearMiss(obstacle) {
    const px = player.x + 4, pw = PLAYER_W - 8;
    const py = player.ducking ? player.y + PLAYER_H * 0.5 : player.y + 4;
    const ph = player.ducking ? PLAYER_H * 0.5 : PLAYER_H - 8;
    const horizOverlap = px + pw > obstacle.x - NEAR_MISS_DETECT_PAD && px < obstacle.x + obstacle.w + NEAR_MISS_DETECT_PAD;
    if (!horizOverlap) return false;
    if (obstacle.type === 'overhead') {
      const gap = obstacle.y + obstacle.h - py;
      return gap > NEAR_MISS_OVERHEAD_GAP_MIN && gap < NEAR_MISS_OVERHEAD_GAP_MAX;
    } else {
      const gap = py + ph - obstacle.y;
      return gap > NEAR_MISS_GROUND_GAP_MIN && gap < NEAR_MISS_GROUND_GAP_MAX;
    }
  }

  function update(dt) {
    // --- Screen Transition Logic ---
    if (slowMotion) {
      dt *= SLOW_MOTION_FACTOR;
      slowMotionTimer -= dt * (1 / SLOW_MOTION_FACTOR); // decrement in real time
      if (slowMotionTimer <= 0) {
        slowMotion = false;
        state = 'gameover';
        gameOverFade = 0;
        gameOverFading = true;
      }
    }

    if (transitionTimer > 0) {
      transitionTimer -= dt;
      transitionAlpha = Math.max(0, transitionTimer / TRANSITION_DURATION);
    }

    if (gameOverFading) {
      gameOverFade = Math.min(1, gameOverFade + dt * GAME_OVER_FADE_SPEED);
      if (gameOverFade >= 1) gameOverFading = false;
    }

    if (state !== 'playing' || paused) return;

    distance += scrollSpeed * dt;
    score = Math.floor(distance / SCORE_DIVISOR) * scoreMultiplier;
    scrollSpeed = Math.min(MAX_SCROLL_SPEED, INITIAL_SCROLL_SPEED + distance * SPEED_RAMP);
    groundOffset = (groundOffset + scrollSpeed * dt) % GROUND_TILE_WIDTH;

    if (scoreMultiplier > 1) {
      scoreMultiplier = Math.max(1, scoreMultiplier - dt * MULTIPLIER_DECAY);
    }

    if (nearMissTimer > 0) nearMissTimer -= dt;

    if (jumpHeld && !player.grounded) {
      jumpTime += dt;
      if (jumpTime > JUMP_HOLD_DURATION) jumpHeld = false;
      else player.vy = Math.min(player.vy, JUMP_VEL * JUMP_HOLD_DAMPEN);
    }

    const prevGrounded = player.grounded;

    player.vy += GRAVITY * dt;
    player.y += player.vy * dt;

    if (player.y >= GROUND_Y - PLAYER_H) {
      player.y = GROUND_Y - PLAYER_H;
      if (!prevGrounded && player.vy > LANDING_SPEED_THRESHOLD) {
        addLandingParticles();
        const impactStrength = Math.min(player.vy / LANDING_IMPACT_DIVISOR, 1);
        triggerShake(impactStrength * LANDING_SHAKE_MULTIPLIER, LANDING_SHAKE_DURATION);
      }
      player.vy = 0;
      player.grounded = true;
      player.jumpsLeft = player.hasDoubleJump ? 1 : 0;
    }

    if (player.ducking) {
      player.duckTimer -= dt;
      if (player.duckTimer <= 0) player.ducking = false;
    }

    if (player.grounded && !player.ducking) {
      player.runTimer += dt;
      if (player.runTimer > RUN_FRAME_INTERVAL) {
        player.runTimer = 0;
        player.runFrame = 1 - player.runFrame;
      }
    }

    if (player.grounded && !player.ducking) {
      dustTimer += dt;
      const dustInterval = Math.max(DUST_INTERVAL_MIN, DUST_INTERVAL_BASE - scrollSpeed * DUST_SPEED_FACTOR);
      if (dustTimer >= dustInterval) {
        dustTimer = 0;
        addDustParticle();
      }
    }

    const currentMilestone = Math.floor(score / MILESTONE_INTERVAL) * MILESTONE_INTERVAL;
    if (currentMilestone > lastMilestone && currentMilestone > 0) {
      lastMilestone = currentMilestone;
      sndMilestone();
      triggerFlash('#FDCB6E', 0.3);
      addFloatingText('+' + currentMilestone, W / 2, H * 0.35, '#FDCB6E', 30);
      scoreMultiplier = Math.min(MAX_SCORE_MULTIPLIER, scoreMultiplier + MULTIPLIER_INCREMENT);
      addFloatingText(scoreMultiplier.toFixed(1) + 'x', W / 2, H * 0.42, '#FF7675', 20);
    }

    if (!newBestTriggered && score > bestScore && bestScore > 0) {
      newBestTriggered = true;
      sndNewBest();
      addFloatingText('NEW BEST!', W / 2, H * 0.25, '#FFD700', 36);
      addNewBestParticles();
      triggerFlash('#FFD700', 0.4);
    }

    spawnTimer -= dt;
    lastObstacleTime += dt;
    if (spawnTimer <= 0) {
      if (lastObstacleTime >= MIN_OBSTACLE_GAP) {
        spawnObstacle();
        spawnTimer = Math.max(SPAWN_TIMER_MIN, SPAWN_TIMER_BASE - distance * SPAWN_TIMER_RAMP) + Math.random() * SPAWN_TIMER_RANDOM;
      } else {
        spawnTimer = MIN_OBSTACLE_GAP - lastObstacleTime;
      }
    }

    for (let i = obstacles.length - 1; i >= 0; i--) {
      const o = obstacles[i];
      o.x -= scrollSpeed * dt;
      if (o.x + o.w < -20) { obstacles.splice(i, 1); continue; }

      if (!o.nearMissChecked && o.x < player.x + PLAYER_W + 5 && o.x + o.w > player.x - 5) {
        if (checkNearMiss(o) && nearMissTimer <= 0) {
          o.nearMissChecked = true;
          nearMissTimer = NEAR_MISS_COOLDOWN;
          score += NEAR_MISS_SCORE;
          nearMissCount++;
          sndNearMiss();
          addFloatingText('NEAR MISS +' + NEAR_MISS_SCORE, player.x + PLAYER_W, player.y - 10, '#FF7675', 16);
        }
      }
      if (o.x + o.w < player.x) o.nearMissChecked = true;

      const px = player.x + 4, pw = PLAYER_W - 8;
      const py = player.ducking ? player.y + PLAYER_H * 0.5 : player.y + 4;
      const ph = player.ducking ? PLAYER_H * 0.5 : PLAYER_H - 8;

      if (px + pw > o.x && px < o.x + o.w && py + ph > o.y && py < o.y + o.h) {
        if (player.hasShield) {
          player.hasShield = false;
          sndShieldBreak();
          addShieldParticles(player.x + PLAYER_W / 2, player.y + PLAYER_H / 2);
          triggerShake(5, 0.2);
          addFloatingText('SHIELD!', player.x + PLAYER_W / 2, player.y - 20, '#74B9FF', 20);
          obstacles.splice(i, 1);
          continue;
        }
        die();
        return;
      }
    }

    for (let i = coins.length - 1; i >= 0; i--) {
      const c = coins[i];
      c.x -= scrollSpeed * dt;
      if (c.x < -20) { coins.splice(i, 1); continue; }

      const dx = (player.x + PLAYER_W / 2) - c.x;
      const dy = (player.y + PLAYER_H / 2) - c.y;
      if (Math.sqrt(dx * dx + dy * dy) < COIN_PICKUP_RANGE) {
        sndCoin();
        player.hasDoubleJump = true;
        addCoinSparkles(c.x, c.y);
        addFloatingText('DOUBLE JUMP!', c.x, c.y - 15, '#FDCB6E', 16);
        coins.splice(i, 1);
      }
    }

    for (let i = shields.length - 1; i >= 0; i--) {
      const s = shields[i];
      s.x -= scrollSpeed * dt;
      if (s.x < -20) { shields.splice(i, 1); continue; }

      const dx = (player.x + PLAYER_W / 2) - s.x;
      const dy = (player.y + PLAYER_H / 2) - s.y;
      if (Math.sqrt(dx * dx + dy * dy) < SHIELD_PICKUP_RANGE) {
        sndShield();
        player.hasShield = true;
        addShieldParticles(s.x, s.y);
        addFloatingText('SHIELD!', s.x, s.y - 15, '#74B9FF', 16);
        shields.splice(i, 1);
      }
    }

    parallaxLayers.forEach(l => { l.offset = (l.offset || 0) + scrollSpeed * l.speed * dt; });

    if (screenShake.timer > 0) {
      screenShake.timer -= dt;
      if (screenShake.timer <= 0) screenShake.timer = 0;
    }

    if (screenFlash.timer > 0) {
      screenFlash.timer -= dt;
      screenFlash.alpha = 0.5 * (screenFlash.timer / screenFlash.duration);
      if (screenFlash.timer <= 0) { screenFlash.timer = 0; screenFlash.alpha = 0; }
    }

    for (let i = floatingTexts.length - 1; i >= 0; i--) {
      const ft = floatingTexts[i];
      ft.y += ft.vy * dt;
      ft.life -= dt;
      if (ft.life <= 0) floatingTexts.splice(i, 1);
    }

    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      p.x += p.vx * dt; p.y += p.vy * dt;
      p.vy += PARTICLE_GRAVITY * dt;
      p.life -= dt * PARTICLE_DECAY;
      if (p.life <= 0) particles.splice(i, 1);
    }
  }

  function spawnObstacle() {
    let r = Math.random();
    // Don't spawn overhead immediately after ground obstacle
    if (r >= OVERHEAD_CHANCE && lastObstacleType === 'ground') {
      r = Math.random() * OVERHEAD_CHANCE;
    }
    if (r < TALL_OBSTACLE_CHANCE) {
      const h = SHORT_OBS_H_MIN + Math.random() * SHORT_OBS_H_RANGE;
      obstacles.push({ x: W + 10, y: GROUND_Y - h, w: SHORT_OBS_W_MIN + Math.random() * SHORT_OBS_W_RANGE, h, type: 'ground', nearMissChecked: false });
      lastObstacleType = 'ground';
    } else if (r < OVERHEAD_CHANCE) {
      obstacles.push({ x: W + 10, y: GROUND_Y - TALL_OBS_BASE_Y - Math.random() * TALL_OBS_Y_RANGE, w: TALL_OBS_W, h: TALL_OBS_H_BASE + Math.random() * TALL_OBS_H_RANGE, type: 'ground', nearMissChecked: false });
      lastObstacleType = 'ground';
    } else {
      obstacles.push({ x: W + 10, y: GROUND_Y - PLAYER_H - OVERHEAD_OBS_OFFSET - Math.random() * OVERHEAD_OBS_Y_RANGE, w: OVERHEAD_OBS_W_MIN + Math.random() * OVERHEAD_OBS_W_RANGE, h: OVERHEAD_OBS_H, type: 'overhead', nearMissChecked: false });
      lastObstacleType = 'overhead';
    }
    lastObstacleTime = 0;

    if (Math.random() < COIN_SPAWN_CHANCE) {
      coins.push({ x: W + COIN_SPAWN_OFFSET_X, y: GROUND_Y - COIN_Y_BASE - Math.random() * COIN_Y_RANGE });
    }

    if (Math.random() < SHIELD_SPAWN_CHANCE && !player.hasShield) {
      shields.push({ x: W + SHIELD_SPAWN_OFFSET_X, y: GROUND_Y - SHIELD_Y_BASE - Math.random() * SHIELD_Y_RANGE });
    }
  }

  function die() {
    if (slowMotion) return; // prevent double-death during slow-motion
    sndHit();
    slowMotion = true;
    slowMotionTimer = SLOW_MOTION_DURATION;
    const prevBest = bestScore;
    bestScore = Math.max(score, bestScore);
    localStorage.setItem('runner_best', bestScore);
    triggerShake(DEATH_SHAKE_INTENSITY, DEATH_SHAKE_DURATION);
    triggerFlash('rgba(255,0,0,0.8)', 0.4);

    for (let i = 0; i < DEATH_PARTICLE_COUNT; i++) {
      const a = Math.random() * Math.PI * 2;
      const speed = DEATH_PARTICLE_SPEED_MIN + Math.random() * DEATH_PARTICLE_SPEED_RANGE;
      particles.push({
        x: player.x + PLAYER_W / 2, y: player.y + PLAYER_H / 2,
        vx: Math.cos(a) * speed, vy: Math.sin(a) * speed,
        life: 1.2, color: '#6C5CE7', size: 3 + Math.random() * 4
      });
    }

    if (score > prevBest && prevBest > 0) {
      if (!newBestTriggered) {
        addNewBestParticles();
        sndNewBest();
      }
      newBestTriggered = true;
    }
  }

  // Mute button constants
  const MUTE_CX = W - 28, MUTE_CY = 98, MUTE_R = 20;
  let muteHovered = false;

  function renderMuteIcon() {
    ctx.save();
    ctx.beginPath();
    ctx.arc(MUTE_CX, MUTE_CY, MUTE_R, 0, Math.PI * 2);
    ctx.fillStyle = muteHovered ? 'rgba(0,0,0,0.45)' : 'rgba(0,0,0,0.3)';
    ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.fillRect(MUTE_CX - 12, MUTE_CY - 4, 6, 8);
    ctx.beginPath();
    ctx.moveTo(MUTE_CX - 6, MUTE_CY - 4);
    ctx.lineTo(MUTE_CX, MUTE_CY - 9);
    ctx.lineTo(MUTE_CX, MUTE_CY + 9);
    ctx.lineTo(MUTE_CX - 6, MUTE_CY + 4);
    ctx.closePath();
    ctx.fill();
    if (muted) {
      ctx.strokeStyle = '#ff6b6b'; ctx.lineWidth = 2.5; ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(MUTE_CX + 3, MUTE_CY - 5); ctx.lineTo(MUTE_CX + 11, MUTE_CY + 5);
      ctx.moveTo(MUTE_CX + 11, MUTE_CY - 5); ctx.lineTo(MUTE_CX + 3, MUTE_CY + 5);
      ctx.stroke();
    } else {
      ctx.strokeStyle = 'rgba(255,255,255,0.85)'; ctx.lineWidth = 1.8; ctx.lineCap = 'round';
      ctx.beginPath(); ctx.arc(MUTE_CX + 2, MUTE_CY, 5, -Math.PI * 0.35, Math.PI * 0.35); ctx.stroke();
      ctx.beginPath(); ctx.arc(MUTE_CX + 2, MUTE_CY, 10, -Math.PI * 0.35, Math.PI * 0.35); ctx.stroke();
    }
    if (muteHovered) {
      const label = muted ? 'Unmute (M)' : 'Mute (M)';
      ctx.font = '12px "Avenir Next", "Segoe UI", system-ui, sans-serif';
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      const tw = ctx.measureText(label).width + 14;
      const ty = MUTE_CY + MUTE_R + 14;
      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      ctx.beginPath(); ctx.roundRect(MUTE_CX - tw / 2, ty - 11, tw, 22, 6); ctx.fill();
      ctx.fillStyle = '#fff'; ctx.fillText(label, MUTE_CX, ty);
    }
    ctx.restore();
  }

  function render() {
    ctx.save();

    if (screenShake.timer > 0) {
      const shakeProgress = screenShake.timer / screenShake.duration;
      const intensity = screenShake.intensity * shakeProgress;
      const sx = (Math.random() - 0.5) * intensity * 2;
      const sy = (Math.random() - 0.5) * intensity * 2;
      ctx.translate(sx, sy);
    }

    const skyColors = getSkyColors();
    const sky = ctx.createLinearGradient(0, 0, 0, GROUND_Y);
    sky.addColorStop(0, skyColors.top);
    sky.addColorStop(1, skyColors.bottom);
    ctx.fillStyle = sky;
    ctx.fillRect(-10, -10, W + 20, GROUND_Y + 20);

    const cycle = (distance % SKY_CYCLE_DISTANCE) / SKY_CYCLE_DISTANCE;
    if (cycle > 0.4 && cycle < 0.9) {
      const nightAlpha = cycle < 0.5 ? (cycle - 0.4) / 0.1 : cycle > 0.8 ? (0.9 - cycle) / 0.1 : 1;
      ctx.fillStyle = '#fff';
      for (let i = 0; i < NIGHT_STAR_COUNT; i++) {
        const starX = ((i * 137 + 53) % W);
        const starY = ((i * 97 + 29) % (GROUND_Y - 100)) + 20;
        const twinkle = 0.5 + 0.5 * Math.sin(Date.now() / (300 + i * 50) + i);
        ctx.globalAlpha = nightAlpha * twinkle * 0.8;
        ctx.beginPath();
        ctx.arc(starX, starY, 1 + (i % 3 === 0 ? 1 : 0), 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;
    }

    parallaxLayers.forEach(l => {
      ctx.fillStyle = l.color;
      l.shapes.forEach(s => {
        const sx = ((s.x - (l.offset || 0)) % (W + MOUNTAIN_STRIP_EXTEND) + W + MOUNTAIN_STRIP_EXTEND) % (W + MOUNTAIN_STRIP_EXTEND) - MOUNTAIN_STRIP_EXTEND / 2;
        ctx.beginPath();
        ctx.moveTo(sx - s.w / 2, l.y + l.h);
        ctx.lineTo(sx, l.y + l.h - s.h);
        ctx.lineTo(sx + s.w / 2, l.y + l.h);
        ctx.closePath();
        ctx.fill();
      });
    });

    ctx.fillStyle = '#00B894';
    ctx.fillRect(-10, GROUND_Y, W + 20, 4);
    ctx.fillStyle = '#E17055';
    ctx.fillRect(-10, GROUND_Y + 4, W + 20, H - GROUND_Y - 4 + 10);

    ctx.fillStyle = '#C0392B';
    for (let x = -groundOffset; x < W + GROUND_TILE_WIDTH; x += GROUND_TILE_WIDTH) {
      ctx.fillRect(x, GROUND_Y + 4, 20, 6);
    }

    obstacles.forEach(o => {
      if (o.type === 'overhead') {
        ctx.fillStyle = '#FD79A8';
        roundRect(o.x, o.y, o.w, o.h, 4);
        ctx.strokeStyle = '#FD79A8';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(o.x + 5, o.y); ctx.lineTo(o.x + 5, 0);
        ctx.moveTo(o.x + o.w - 5, o.y); ctx.lineTo(o.x + o.w - 5, 0);
        ctx.stroke();
      } else {
        ctx.fillStyle = '#E74C3C';
        roundRect(o.x, o.y, o.w, o.h, 4);
        ctx.fillStyle = 'rgba(255,255,255,0.15)';
        ctx.fillRect(o.x + 3, o.y + 3, o.w - 6, 4);
      }
    });

    coins.forEach(c => {
      const pulse = 1 + COIN_PULSE_AMPLITUDE * Math.sin(Date.now() / COIN_PULSE_SPEED);
      ctx.fillStyle = '#FDCB6E';
      ctx.shadowColor = '#FDCB6E';
      ctx.shadowBlur = COIN_GLOW_BLUR;
      ctx.beginPath(); ctx.arc(c.x, c.y, COIN_RADIUS * pulse, 0, Math.PI * 2); ctx.fill();
      ctx.shadowBlur = 0;
      ctx.fillStyle = '#F39C12';
      ctx.font = 'bold 12px "Avenir Next", "Segoe UI", system-ui, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('+', c.x, c.y + 4);
    });

    shields.forEach(s => {
      const pulse = 1 + SHIELD_PULSE_AMPLITUDE * Math.sin(Date.now() / SHIELD_PULSE_SPEED);
      ctx.fillStyle = '#74B9FF';
      ctx.shadowColor = '#0984E3';
      ctx.shadowBlur = SHIELD_GLOW_BLUR;
      ctx.beginPath(); ctx.arc(s.x, s.y, SHIELD_RADIUS * pulse, 0, Math.PI * 2); ctx.fill();
      ctx.shadowBlur = 0;
      ctx.fillStyle = '#0984E3';
      ctx.font = 'bold 14px "Avenir Next", "Segoe UI", system-ui, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('\u2666', s.x, s.y + 5);
    });

    const px = player.x, py = player.y;
    ctx.save();

    if (player.hasShield) {
      const shieldAlpha = 0.4 + 0.3 * Math.sin(Date.now() / 300);
      ctx.strokeStyle = 'rgba(116, 185, 255, ' + shieldAlpha + ')';
      ctx.lineWidth = 3;
      ctx.shadowColor = '#0984E3';
      ctx.shadowBlur = 10;
      ctx.beginPath();
      if (player.ducking) {
        ctx.ellipse(px + PLAYER_W / 2 + 5, py + PLAYER_H - 10, PLAYER_W, 16, 0, 0, Math.PI * 2);
      } else {
        ctx.ellipse(px + PLAYER_W / 2, py + PLAYER_H / 2, PLAYER_W * 0.7, PLAYER_H * 0.6, 0, 0, Math.PI * 2);
      }
      ctx.stroke();
      ctx.shadowBlur = 0;
    }

    if (player.ducking) {
      ctx.fillStyle = '#6C5CE7';
      roundRect(px, py + PLAYER_H - 20, PLAYER_W + 10, 20, 6);
      ctx.fillStyle = '#6C5CE7';
      ctx.beginPath(); ctx.arc(px + PLAYER_W + 5, py + PLAYER_H - 10, 8, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#fff';
      ctx.beginPath(); ctx.arc(px + PLAYER_W + 8, py + PLAYER_H - 12, 3, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#2D3436';
      ctx.beginPath(); ctx.arc(px + PLAYER_W + 9, py + PLAYER_H - 12, 1.5, 0, Math.PI * 2); ctx.fill();
    } else {
      ctx.fillStyle = '#6C5CE7';
      roundRect(px + 3, py + 15, PLAYER_W - 6, PLAYER_H - 25, 6);

      ctx.beginPath(); ctx.arc(px + PLAYER_W / 2, py + 10, 10, 0, Math.PI * 2); ctx.fill();

      ctx.fillStyle = '#fff';
      ctx.beginPath(); ctx.arc(px + PLAYER_W / 2 + 4, py + 8, 3.5, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#2D3436';
      ctx.beginPath(); ctx.arc(px + PLAYER_W / 2 + 5, py + 8, 1.8, 0, Math.PI * 2); ctx.fill();

      ctx.strokeStyle = '#6C5CE7';
      ctx.lineWidth = 4;
      ctx.lineCap = 'round';
      if (player.grounded) {
        const legAnim = player.runFrame === 0 ? 1 : -1;
        ctx.beginPath();
        ctx.moveTo(px + 10, py + PLAYER_H - 10);
        ctx.lineTo(px + 10 + legAnim * 8, py + PLAYER_H);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(px + 20, py + PLAYER_H - 10);
        ctx.lineTo(px + 20 - legAnim * 8, py + PLAYER_H);
        ctx.stroke();
      } else {
        ctx.beginPath();
        ctx.moveTo(px + 12, py + PLAYER_H - 10);
        ctx.lineTo(px + 10, py + PLAYER_H);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(px + 18, py + PLAYER_H - 10);
        ctx.lineTo(px + 20, py + PLAYER_H);
        ctx.stroke();
      }
    }

    if (player.hasDoubleJump) {
      ctx.fillStyle = 'rgba(253, 203, 110, 0.6)';
      ctx.beginPath(); ctx.arc(px + PLAYER_W / 2, py - 5, 4, 0, Math.PI * 2); ctx.fill();
    }

    ctx.restore();

    particles.forEach(p => {
      ctx.globalAlpha = Math.max(0, p.life);
      ctx.fillStyle = p.color;
      if (p.sparkle) {
        const sz = p.size * (0.5 + 0.5 * Math.sin(Date.now() / 100 + p.x));
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(Date.now() / 200 + p.x);
        ctx.fillRect(-sz / 2, -sz / 2, sz, sz);
        ctx.restore();
      } else {
        ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill();
      }
    });
    ctx.globalAlpha = 1;

    if (scrollSpeed > SPEED_LINES_THRESHOLD) {
      const lineIntensity = Math.min(1, (scrollSpeed - SPEED_LINES_THRESHOLD) / SPEED_LINES_RANGE);
      const lineCount = Math.floor(SPEED_LINES_BASE_COUNT + lineIntensity * SPEED_LINES_MAX_EXTRA);
      ctx.strokeStyle = 'rgba(255,255,255,' + (0.08 + lineIntensity * 0.15) + ')';
      ctx.lineWidth = 1;
      for (let i = 0; i < lineCount; i++) {
        const ly = 60 + Math.random() * (GROUND_Y - 100);
        const lx = Math.random() * W;
        const lineLen = SPEED_LINE_BASE_LEN + lineIntensity * SPEED_LINE_MAX_EXTRA_LEN;
        ctx.beginPath(); ctx.moveTo(lx, ly); ctx.lineTo(lx - lineLen, ly); ctx.stroke();
      }
    }

    floatingTexts.forEach(ft => {
      const ftAlpha = Math.max(0, ft.life / ft.maxLife);
      ctx.globalAlpha = ftAlpha;
      ctx.fillStyle = ft.color;
      ctx.font = 'bold ' + ft.size + 'px "Avenir Next", "Segoe UI", system-ui, sans-serif';
      ctx.textAlign = 'center';
      ctx.shadowColor = 'rgba(0,0,0,0.5)';
      ctx.shadowBlur = FLOATING_TEXT_SHADOW_BLUR;
      ctx.fillText(ft.text, ft.x, ft.y);
      ctx.shadowBlur = 0;
    });
    ctx.globalAlpha = 1;

    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    ctx.font = 'bold 28px "Avenir Next", "Segoe UI", system-ui, sans-serif';
    ctx.textAlign = 'right';
    ctx.shadowColor = 'rgba(255,255,255,0.6)';
    ctx.shadowBlur = 12;
    ctx.fillText(Math.floor(score), W - 20, 40);
    ctx.shadowBlur = 0;

    if (scoreMultiplier > 1) {
      ctx.fillStyle = '#FF7675';
      ctx.font = 'bold 16px "Avenir Next", "Segoe UI", system-ui, sans-serif';
      ctx.fillText(scoreMultiplier.toFixed(1) + 'x', W - 20, 60);
    }

    if (player.hasShield) {
      ctx.fillStyle = '#74B9FF';
      ctx.font = '14px "Avenir Next", "Segoe UI", system-ui, sans-serif';
      ctx.textAlign = 'right';
      ctx.fillText('\u2666 SHIELD', W - 20, scoreMultiplier > 1 ? 78 : 60);
    }

    if (screenFlash.alpha > 0) {
      ctx.fillStyle = screenFlash.color;
      ctx.globalAlpha = screenFlash.alpha;
      ctx.fillRect(-10, -10, W + 20, H + 20);
      ctx.globalAlpha = 1;
    }

    renderMuteIcon();

    // --- Fade-in overlay ---
    if (transitionAlpha > 0) {
      ctx.fillStyle = 'rgba(0,0,0,' + transitionAlpha + ')';
      ctx.fillRect(-10, -10, W + 20, H + 20);
    }

    ctx.restore();
  }

  function renderTitle() {
    render();
    ctx.fillStyle = 'rgba(0,0,0,0.35)';
    ctx.fillRect(0, 0, W, H);

    ctx.fillStyle = '#fff';
    ctx.font = 'bold 40px "Avenir Next", "Segoe UI", system-ui, sans-serif';
    ctx.textAlign = 'center';
    ctx.shadowColor = 'rgba(0,0,0,0.3)';
    ctx.shadowBlur = 10;
    ctx.fillText('ENDLESS', W / 2, H * 0.28);
    ctx.fillText('RUNNER', W / 2, H * 0.36);
    ctx.shadowBlur = 0;

    const alpha = 0.5 + 0.5 * Math.sin(Date.now() / 500);
    ctx.globalAlpha = alpha;
    ctx.font = '22px "Avenir Next", "Segoe UI", system-ui, sans-serif';
    ctx.fillText('Tap to Play', W / 2, H * 0.50);
    ctx.globalAlpha = 1;

    ctx.font = '14px "Avenir Next", "Segoe UI", system-ui, sans-serif';
    ctx.fillStyle = 'rgba(255,255,255,0.5)';
    ctx.fillText('Tap/Space = Jump, Down = Duck', W / 2, H * 0.55);
    ctx.fillText('Swipe down to duck on mobile', W / 2, H * 0.59);
    ctx.fillText('P = Pause, M = Mute', W / 2, H * 0.63);

    if (bestScore > 0) {
      ctx.fillStyle = '#FDCB6E';
      ctx.font = '18px "Avenir Next", "Segoe UI", system-ui, sans-serif';
      ctx.fillText('Best: ' + bestScore, W / 2, H * 0.70);
    }

    renderMuteIcon();
  }

  function renderPause() {
    render();
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.fillRect(0, 0, W, H);

    ctx.fillStyle = '#fff';
    ctx.font = 'bold 44px "Avenir Next", "Segoe UI", system-ui, sans-serif';
    ctx.textAlign = 'center';
    ctx.shadowColor = 'rgba(0,0,0,0.3)';
    ctx.shadowBlur = 10;
    ctx.fillText('PAUSED', W / 2, H * 0.38);
    ctx.shadowBlur = 0;

    const alpha = 0.5 + 0.5 * Math.sin(Date.now() / 500);
    ctx.globalAlpha = alpha;
    ctx.font = '22px "Avenir Next", "Segoe UI", system-ui, sans-serif';
    ctx.fillText('Press P to Resume', W / 2, H * 0.48);
    ctx.globalAlpha = 1;

    ctx.font = '16px "Avenir Next", "Segoe UI", system-ui, sans-serif';
    ctx.fillStyle = 'rgba(255,255,255,0.5)';
    ctx.fillText('Score: ' + Math.floor(score), W / 2, H * 0.55);

    renderMuteIcon();
  }

  function renderGameOver() {
    render();

    const fade = gameOverFading || gameOverFade < 1 ? gameOverFade : 1;
    ctx.fillStyle = 'rgba(0,0,0,' + (0.6 * fade) + ')';
    ctx.fillRect(0, 0, W, H);

    ctx.globalAlpha = fade;

    ctx.fillStyle = '#fff';
    ctx.font = 'bold 44px "Avenir Next", "Segoe UI", system-ui, sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Game Over', W / 2, H * 0.28);
    ctx.font = 'bold 64px "Avenir Next", "Segoe UI", system-ui, sans-serif';
    ctx.fillText(Math.floor(score), W / 2, H * 0.42);
    ctx.font = '20px "Avenir Next", "Segoe UI", system-ui, sans-serif';
    ctx.fillStyle = '#FDCB6E';
    ctx.fillText('Best: ' + bestScore, W / 2, H * 0.48);

    ctx.font = '15px "Avenir Next", "Segoe UI", system-ui, sans-serif';
    ctx.fillStyle = 'rgba(255,255,255,0.55)';
    ctx.fillText('Distance: ' + Math.floor(distance) + 'm', W / 2, H * 0.53);
    ctx.fillText('Near Misses: ' + nearMissCount, W / 2, H * 0.57);

    if (newBestTriggered) {
      const pulseAlpha = (0.7 + 0.3 * Math.sin(Date.now() / 300)) * fade;
      ctx.globalAlpha = pulseAlpha;
      ctx.fillStyle = '#FFD700';
      ctx.font = 'bold 28px "Avenir Next", "Segoe UI", system-ui, sans-serif';
      ctx.shadowColor = '#FFD700';
      ctx.shadowBlur = 15;
      ctx.fillText('NEW BEST!', W / 2, H * 0.22);
      ctx.shadowBlur = 0;
      ctx.globalAlpha = fade;
    }

    ctx.fillStyle = '#6C5CE7';
    roundRect(W / 2 - 90, H * 0.63, 180, 50, 25);
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 20px "Avenir Next", "Segoe UI", system-ui, sans-serif';
    ctx.fillText('Play Again', W / 2, H * 0.63 + 32);

    ctx.globalAlpha = 1;

    floatingTexts.forEach(ft => {
      const ftA = Math.max(0, ft.life / ft.maxLife);
      ctx.globalAlpha = ftA;
      ctx.fillStyle = ft.color;
      ctx.font = 'bold ' + ft.size + 'px "Avenir Next", "Segoe UI", system-ui, sans-serif';
      ctx.textAlign = 'center';
      ctx.shadowColor = 'rgba(0,0,0,0.5)';
      ctx.shadowBlur = FLOATING_TEXT_SHADOW_BLUR;
      ctx.fillText(ft.text, ft.x, ft.y);
      ctx.shadowBlur = 0;
    });
    ctx.globalAlpha = 1;

    particles.forEach(p => {
      ctx.globalAlpha = Math.max(0, p.life);
      ctx.fillStyle = p.color;
      if (p.sparkle) {
        const sz = p.size * (0.5 + 0.5 * Math.sin(Date.now() / 100 + p.x));
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(Date.now() / 200 + p.x);
        ctx.fillRect(-sz / 2, -sz / 2, sz, sz);
        ctx.restore();
      } else {
        ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill();
      }
    });
    ctx.globalAlpha = 1;

    renderMuteIcon();
  }

  function roundRect(x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    ctx.fill();
  }

  function gameLoop(ts) {
    const dt = Math.min((ts - lastTime) / 1000, 0.05);
    lastTime = ts;

    if (state === 'gameover' || paused) {
      for (let i = floatingTexts.length - 1; i >= 0; i--) {
        floatingTexts[i].y += floatingTexts[i].vy * dt;
        floatingTexts[i].life -= dt;
        if (floatingTexts[i].life <= 0) floatingTexts.splice(i, 1);
      }
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx * dt; p.y += p.vy * dt;
        p.vy += 300 * dt;
        p.life -= dt * 3;
        if (p.life <= 0) particles.splice(i, 1);
      }
      if (screenShake.timer > 0) screenShake.timer = Math.max(0, screenShake.timer - dt);
      if (screenFlash.timer > 0) {
        screenFlash.timer -= dt;
        screenFlash.alpha = 0.5 * (screenFlash.timer / screenFlash.duration);
        if (screenFlash.timer <= 0) { screenFlash.timer = 0; screenFlash.alpha = 0; }
      }
    }

    update(dt);

    if (state === 'title') renderTitle();
    else if (state === 'playing' && paused) renderPause();
    else if (state === 'playing') render();
    else renderGameOver();

    requestAnimationFrame(gameLoop);
  }

  function isMuteIconClick(clientX, clientY) {
    const rect = canvas.getBoundingClientRect();
    const x = (clientX - rect.left) * (W / rect.width);
    const y = (clientY - rect.top) * (H / rect.height);
    const dx = x - MUTE_CX, dy = y - MUTE_CY;
    return dx * dx + dy * dy <= (MUTE_R + 4) * (MUTE_R + 4);
  }

  canvas.addEventListener('mousemove', e => {
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (W / rect.width);
    const y = (e.clientY - rect.top) * (H / rect.height);
    const dx = x - MUTE_CX, dy = y - MUTE_CY;
    muteHovered = dx * dx + dy * dy <= (MUTE_R + 4) * (MUTE_R + 4);
    canvas.style.cursor = muteHovered ? 'pointer' : 'default';
  });
  canvas.addEventListener('mouseleave', () => { muteHovered = false; });

  let touchStartY = null;
  canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    const touch = e.touches[0];
    if (isMuteIconClick(touch.clientX, touch.clientY)) {
      toggleMute();
      return;
    }
    touchStartY = touch.clientY;
    jump();
  }, { passive: false });

  canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    if (touchStartY !== null) {
      const dy = e.touches[0].clientY - touchStartY;
      if (dy > SWIPE_DOWN_THRESHOLD) { duck(true); touchStartY = null; }
    }
  }, { passive: false });

  canvas.addEventListener('touchend', e => {
    e.preventDefault();
    jumpHeld = false;
    touchStartY = null;
  }, { passive: false });

  canvas.addEventListener('mousedown', e => {
    if (isMuteIconClick(e.clientX, e.clientY)) {
      toggleMute();
      return;
    }
    jump();
  });
  canvas.addEventListener('mouseup', () => { jumpHeld = false; });

  document.addEventListener('keydown', e => {
    if (e.code === 'Space' || e.code === 'ArrowUp') { e.preventDefault(); jump(); }
    if (e.code === 'ArrowDown' || e.code === 'KeyS') { e.preventDefault(); duck(true); }
    if (e.code === 'KeyP') { e.preventDefault(); togglePause(); }
    if (e.code === 'KeyM') { e.preventDefault(); toggleMute(); }
  });
  document.addEventListener('keyup', e => {
    if (e.code === 'Space' || e.code === 'ArrowUp') jumpHeld = false;
  });

  init();
  requestAnimationFrame(gameLoop);
})();
</script>
</body>
</html>